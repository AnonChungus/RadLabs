<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RadLabs | Bitcoin Runes Trading</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- TradingView Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    :root {
      /* Miami Vice Modern Palette */
      --miami-pink: #ff2d92;
      --miami-cyan: #00d4ff;
      --miami-purple: #9945ff;
      --miami-orange: #ff6b35;
      --miami-sunset: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      
      /* Matrix Numbers */
      --matrix-green: #00ff41;
      --matrix-dim: #00cc33;
      
      /* Modern Apple-style */
      --glass-bg: rgba(255,255,255,0.03);
      --glass-border: rgba(255,255,255,0.08);
      --card-bg: rgba(20,20,35,0.8);
      --card-border: rgba(255,255,255,0.06);
      
      /* Base */
      --bg-primary: #0a0a12;
      --bg-secondary: #0f0f1a;
      --text-primary: #ffffff;
      --text-secondary: rgba(255,255,255,0.6);
      --text-muted: rgba(255,255,255,0.4);
      
      /* Status */
      --green: #00ff88;
      --red: #ff4757;
      --yellow: #ffd93d;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    /* ===== BACKGROUND ===== */
    .bg-gradient {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: 
        radial-gradient(ellipse at 20% 20%, rgba(255,45,146,0.15) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(0,212,255,0.1) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(153,69,255,0.05) 0%, transparent 70%),
        var(--bg-primary);
      z-index: -2;
    }
    
    .bg-grid {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-image: 
        linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
      background-size: 60px 60px;
      z-index: -1;
    }
    
    /* Palm tree decorations */
    .palm-left, .palm-right {
      position: fixed;
      bottom: 0;
      width: 200px;
      height: 400px;
      opacity: 0.1;
      z-index: -1;
      background-size: contain;
      background-repeat: no-repeat;
      filter: hue-rotate(280deg);
    }
    .palm-left { left: 0; }
    .palm-right { right: 0; transform: scaleX(-1); }
    
    /* ===== LOTTERY BANNER ===== */
    .lottery-banner {
      background: linear-gradient(90deg, rgba(255,45,146,0.1), rgba(0,212,255,0.1), rgba(153,69,255,0.1));
      border-bottom: 1px solid var(--glass-border);
      padding: 0.6rem 2rem;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      font-size: 0.85rem;
    }
    
    .lottery-timer {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .lottery-timer .icon {
      font-size: 1.2rem;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .lottery-slots {
      display: flex;
      gap: 0.25rem;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
      font-size: 1.1rem;
    }
    
    .slot-digit {
      background: rgba(0,255,65,0.1);
      border: 1px solid var(--matrix-green);
      color: var(--matrix-green);
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      min-width: 28px;
      text-align: center;
      text-shadow: 0 0 10px var(--matrix-green);
    }
    
    .lottery-prize {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--yellow);
    }
    
    .lottery-prize .amount {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
      font-size: 1rem;
    }
    
    /* ===== HEADER ===== */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 2rem;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--glass-border);
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .logo-icon {
      width: 42px;
      height: 42px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .logo-icon svg {
      width: 100%;
      height: 100%;
      filter: drop-shadow(0 2px 4px rgba(0,255,100,0.3));
    }
    
    .logo-text {
      font-family: 'Inter', sans-serif;
      font-size: 1.7rem;
      font-weight: 900;
      letter-spacing: 0.5px;
    }
    
    .logo-text .rad {
      color: #111111;
      -webkit-text-stroke: 1.5px #ff6b35;
      paint-order: stroke fill;
    }
    
    .logo-text .labs {
      color: #ff6b35;
      font-weight: 900;
      margin-left: 2px;
    }
    
    .nav {
      display: flex;
      gap: 0.25rem;
      background: var(--card-bg);
      padding: 0.25rem;
      border-radius: 12px;
      border: 1px solid var(--card-border);
    }
    
    .nav a {
      color: var(--text-secondary);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.9rem;
      padding: 0.6rem 1.25rem;
      border-radius: 10px;
      transition: all 0.2s;
    }
    
    .nav a:hover {
      color: var(--text-primary);
      background: rgba(255,255,255,0.05);
    }
    
    .nav a.active {
      color: var(--text-primary);
      background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
      border: 2px solid transparent;
      background-image: 
        linear-gradient(135deg, #1a1a1a, #2d2d2d),
        linear-gradient(135deg, var(--miami-pink), var(--miami-cyan));
      background-origin: border-box;
      background-clip: padding-box, border-box;
    }
    
    .connect-btn {
      font-family: inherit;
      background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
      color: white;
      border: 2px solid transparent;
      background-image: 
        linear-gradient(135deg, #1a1a1a, #2d2d2d),
        linear-gradient(135deg, var(--miami-pink), var(--miami-cyan));
      background-origin: border-box;
      background-clip: padding-box, border-box;
      padding: 0.75rem 1.5rem;
      border-radius: 12px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .connect-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(255,45,146,0.3);
    }
    
    /* Balance Display */
    .balance-display {
      display: flex;
      gap: 1.5rem;
      align-items: center;
      padding: 0.5rem 1rem;
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      border: 1px solid var(--card-border);
    }
    
    .balance-item {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }
    
    .balance-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.25rem;
    }
    
    .balance-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      color: var(--text-primary);
      font-weight: 600;
    }
    
    .connect-btn.connected {
      background-image: 
        linear-gradient(135deg, #1a1a1a, #2d2d2d),
        linear-gradient(135deg, var(--green), var(--miami-cyan));
      box-shadow: 0 4px 20px rgba(0,255,136,0.3);
    }
    
    /* ===== PAGES ===== */
    .page {
      display: none;
      padding: 1.5rem 2rem;
      max-width: 1600px;
      margin: 0 auto;
      padding-bottom: 100px;
    }
    
    .page.active { display: block; }
    
    /* ===== TRADE PAGE ===== */
    .trade-grid {
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: 1.5rem;
    }
    
    .chart-card {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      border: 1px solid var(--card-border);
      overflow: hidden;
    }
    
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--card-border);
    }
    
    .token-display {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .token-img {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--miami-orange), var(--miami-pink));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      border: 2px solid var(--card-border);
      overflow: hidden;
    }
    
    .token-img img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .token-meta h2 {
      font-size: 1.25rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .token-meta .rune {
      font-size: 0.8rem;
      color: var(--text-muted);
      font-weight: 400;
    }
    
    .token-stats {
      display: flex;
      gap: 1.5rem;
      margin-top: 0.25rem;
    }
    
    .token-stats span {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    
    .token-stats .val {
      font-family: 'JetBrains Mono', monospace;
      color: var(--matrix-green);
    }
    
    .price-box {
      text-align: right;
    }
    
    .price-box .price {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.75rem;
      font-weight: 700;
      color: var(--matrix-green);
      text-shadow: 0 0 20px rgba(0,255,65,0.3);
    }
    
    .price-box .price-usd {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }
    
    .price-box .change {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.95rem;
      font-weight: 600;
    }
    
    .change.up { color: var(--green); }
    .change.down { color: var(--red); }
    
    /* Chart Container */
    .chart-container {
      position: relative;
      height: 400px;
    }
    
    .chart-video-bg {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      min-width: 100%;
      min-height: 100%;
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.5;
      z-index: 0;
      pointer-events: none;
    }
    
    .mute-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      border: 1px solid var(--miami-cyan);
      color: var(--miami-cyan);
      padding: 0.5rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.2rem;
      transition: all 0.2s;
      backdrop-filter: blur(10px);
    }
    
    .mute-btn:hover {
      background: rgba(0,212,255,0.2);
      border-color: var(--miami-cyan);
      transform: scale(1.1);
    }
    
    #tvChart {
      position: relative;
      z-index: 1;
      width: 100%;
      height: 100%;
    }
    
    .chart-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: rgba(0,0,0,0.3);
      border-top: 1px solid var(--card-border);
    }
    
    .chart-timeframes {
      display: flex;
      gap: 0.25rem;
    }
    
    .tf-btn {
      font-family: 'JetBrains Mono', monospace;
      background: transparent;
      border: 1px solid var(--card-border);
      color: var(--text-secondary);
      padding: 0.4rem 0.7rem;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .tf-btn:hover, .tf-btn.active {
      background: var(--miami-cyan);
      border-color: var(--miami-cyan);
      color: var(--bg-primary);
    }
    
    .chart-type-btns {
      display: flex;
      gap: 0.25rem;
    }
    
    .chart-type-btn {
      background: transparent;
      border: 1px solid var(--card-border);
      color: var(--text-secondary);
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    
    .chart-type-btn:hover, .chart-type-btn.active {
      background: var(--miami-pink);
      border-color: var(--miami-pink);
      color: white;
    }
    
    /* ===== TRADE PANEL ===== */
    .trade-panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .panel-card {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      border: 1px solid var(--card-border);
      padding: 1.25rem;
    }
    
    .panel-tabs {
      display: flex;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 0.25rem;
      margin-bottom: 1rem;
    }
    
    .panel-tab {
      flex: 1;
      padding: 0.6rem;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-family: inherit;
      font-weight: 600;
      font-size: 0.9rem;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .panel-tab.active.buy {
      background: var(--green);
      color: var(--bg-primary);
    }
    
    .panel-tab.active.sell {
      background: var(--red);
      color: white;
    }
    
    .quick-amounts {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    .quick-btn {
      font-family: 'JetBrains Mono', monospace;
      background: rgba(0,255,136,0.1);
      border: 1px solid var(--green);
      color: var(--green);
      padding: 0.5rem;
      border-radius: 8px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .quick-btn:hover {
      background: var(--green);
      color: var(--bg-primary);
    }
    
    .input-group {
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 0.75rem;
    }
    
    .input-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      gap: 0.5rem;
    }
    
    .input-label > span {
      white-space: nowrap;
    }
    
    .input-row {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      overflow: hidden;
    }
    
    .input-field {
      flex: 1;
      min-width: 0;
      background: transparent;
      border: none;
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.4rem;
      color: var(--matrix-green);
      outline: none;
    }
    
    .input-field::placeholder {
      color: var(--text-muted);
    }
    
    .token-select {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--card-border);
      padding: 0.5rem 0.75rem;
      border-radius: 20px;
      cursor: pointer;
      flex-shrink: 0;
      white-space: nowrap;
      max-width: 120px;
    }
    
    .token-select span {
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .token-select .mini-img {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--miami-orange), var(--miami-pink));
    }
    
    .swap-arrow {
      display: flex;
      justify-content: center;
      margin: -0.5rem 0;
      position: relative;
      z-index: 2;
    }
    
    .swap-arrow button {
      background: var(--card-bg);
      border: 2px solid var(--miami-cyan);
      color: var(--miami-cyan);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s;
    }
    
    .swap-arrow button:hover {
      background: var(--miami-cyan);
      color: var(--bg-primary);
      transform: rotate(180deg);
    }
    
    .trade-info {
      padding: 0.75rem 0;
      border-top: 1px solid var(--card-border);
      margin-top: 0.5rem;
    }
    
    .info-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      margin-bottom: 0.4rem;
    }
    
    .info-row .label { color: var(--text-muted); }
    .info-row .value { 
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-primary);
    }
    .info-row .value.fee { color: var(--miami-pink); }
    
    .trade-btn {
      width: 100%;
      padding: 1rem;
      border: none;
      border-radius: 12px;
      font-family: inherit;
      font-weight: 700;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 0.5rem;
    }
    
    .trade-btn.buy {
      background: linear-gradient(135deg, var(--green), #00cc77);
      color: var(--bg-primary);
      box-shadow: 0 4px 20px rgba(0,255,136,0.3);
    }
    
    .trade-btn.sell {
      background: linear-gradient(135deg, var(--red), #cc3344);
      color: white;
      box-shadow: 0 4px 20px rgba(255,71,87,0.3);
    }
    
    .trade-btn:disabled {
      background: var(--card-bg);
      color: var(--text-muted);
      box-shadow: none;
      cursor: not-allowed;
    }
    
    /* Health indicator */
    .health-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
    }
    
    .health-badge {
      background: rgba(0,255,136,0.1);
      color: var(--green);
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    
    /* ===== TOKEN TABLE ===== */
    .token-list-card {
      margin-top: 1.5rem;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      border: 1px solid var(--card-border);
      overflow: hidden;
    }
    
    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--card-border);
    }
    
    .list-header h3 {
      font-size: 1.1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .live-dot {
      width: 8px;
      height: 8px;
      background: var(--green);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    .search-box {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--card-border);
      border-radius: 10px;
      padding: 0.5rem 1rem;
    }
    
    .search-box input {
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.9rem;
      outline: none;
      width: 200px;
    }
    
    .token-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .token-table th {
      text-align: left;
      padding: 0.75rem 1rem;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      background: rgba(0,0,0,0.2);
      border-bottom: 1px solid var(--card-border);
    }
    
    .token-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--card-border);
      font-size: 0.9rem;
    }
    
    .token-table tbody tr {
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .token-table tbody tr:hover {
      background: rgba(255,45,146,0.05);
    }
    
    .token-cell {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .token-cell .img {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--miami-orange), var(--miami-pink));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      overflow: hidden;
    }
    
    .token-cell .img img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .token-cell .name {
      font-weight: 600;
    }
    
    .token-cell .rune {
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    
    .mono {
      font-family: 'JetBrains Mono', monospace;
    }
    
    .green { color: var(--matrix-green) !important; }
    .up { color: var(--green) !important; }
    .down { color: var(--red) !important; }
    
    /* ===== GAMES PAGE ===== */
    .games-header {
      text-align: center;
      padding: 2rem 0;
    }
    
    .games-header h1 {
      font-size: 2.5rem;
      font-weight: 800;
      background: linear-gradient(90deg, var(--miami-pink), var(--miami-cyan), var(--miami-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem;
    }
    
    .games-header p {
      color: var(--text-secondary);
      font-size: 1.1rem;
    }
    
    .games-header .rake-info {
      display: inline-block;
      background: rgba(255,45,146,0.1);
      border: 1px solid var(--miami-pink);
      color: var(--miami-pink);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      margin-top: 1rem;
      font-size: 0.9rem;
    }
    
    .games-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 1.5rem;
      margin-top: 1.5rem;
    }
    
    .game-card {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      border: 1px solid var(--card-border);
      overflow: hidden;
      transition: all 0.3s;
    }
    
    .game-card:hover {
      border-color: var(--miami-pink);
      transform: translateY(-5px);
      box-shadow: 0 20px 40px rgba(255,45,146,0.2);
    }
    
    .game-preview {
      height: 200px;
      background: linear-gradient(135deg, var(--bg-secondary), var(--bg-primary));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4rem;
      position: relative;
      overflow: hidden;
    }
    
    .game-preview .bg-anim {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(45deg, transparent 30%, rgba(255,45,146,0.1) 50%, transparent 70%);
      animation: shine 3s infinite;
    }
    
    @keyframes shine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    .game-info {
      padding: 1.25rem;
    }
    
    .game-info h3 {
      font-size: 1.25rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }
    
    .game-info p {
      color: var(--text-secondary);
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }
    
    .game-stats {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .game-stat {
      flex: 1;
      background: rgba(0,0,0,0.3);
      padding: 0.5rem;
      border-radius: 8px;
      text-align: center;
    }
    
    .game-stat .label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    
    .game-stat .value {
      font-family: 'JetBrains Mono', monospace;
      color: var(--matrix-green);
      font-weight: 600;
    }
    
    .play-btn {
      width: 100%;
      padding: 0.75rem;
      background: linear-gradient(135deg, var(--miami-pink), var(--miami-purple));
      border: none;
      border-radius: 10px;
      color: white;
      font-family: inherit;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .play-btn:hover {
      box-shadow: 0 4px 20px rgba(255,45,146,0.4);
    }
    
    /* Crash Game */
    .crash-game {
      background: var(--card-bg);
      border-radius: 16px;
      border: 1px solid var(--card-border);
      padding: 1.5rem;
      margin-top: 1.5rem;
    }
    
    .crash-display {
      height: 300px;
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    
    .crash-multiplier {
      font-family: 'JetBrains Mono', monospace;
      font-size: 5rem;
      font-weight: 700;
      color: var(--matrix-green);
      text-shadow: 0 0 40px rgba(0,255,65,0.5);
    }
    
    .crash-multiplier.crashed {
      color: var(--red);
      text-shadow: 0 0 40px rgba(255,71,87,0.5);
    }
    
    .crash-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .crash-input {
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--card-border);
      border-radius: 10px;
      padding: 1rem;
    }
    
    .crash-input label {
      display: block;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }
    
    .crash-input input {
      width: 100%;
      background: transparent;
      border: none;
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.25rem;
      color: var(--matrix-green);
      outline: none;
    }
    
    .crash-btns {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    
    .crash-btns button {
      flex: 1;
      padding: 1rem;
      border: none;
      border-radius: 10px;
      font-family: inherit;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
    }
    
    .bet-btn {
      background: linear-gradient(135deg, var(--green), #00cc77);
      color: var(--bg-primary);
    }
    
    .cashout-btn {
      background: linear-gradient(135deg, var(--miami-pink), var(--miami-purple));
      color: white;
    }
    
    /* ===== MODALS ===== */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(10px);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    
    .modal-overlay.active { display: flex; }
    
    .modal {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-radius: 20px;
      border: 1px solid var(--card-border);
      padding: 1.5rem;
      width: 90%;
      max-width: 420px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .modal h3 {
      font-size: 1.25rem;
      font-weight: 700;
      text-align: center;
      margin-bottom: 1.5rem;
    }
    
    .wallet-option {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      cursor: pointer;
      margin-bottom: 0.75rem;
      transition: all 0.2s;
    }
    
    .wallet-option:hover {
      border-color: var(--miami-pink);
      background: rgba(255,45,146,0.05);
    }
    
    .wallet-option img {
      width: 44px;
      height: 44px;
      border-radius: 10px;
    }
    
    .wallet-option .name {
      font-weight: 600;
    }
    
    .wallet-option .desc {
      font-size: 0.85rem;
      color: var(--text-muted);
    }
    
    /* ===== TICKER ===== */
    .ticker {
      position: fixed;
      bottom: 0; left: 0;
      width: 100%;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-top: 1px solid var(--card-border);
      padding: 0.6rem 0;
      z-index: 99;
      overflow: hidden;
    }
    
    .ticker-track {
      display: flex;
      animation: scroll 50s linear infinite;
      white-space: nowrap;
    }
    
    @keyframes scroll {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }
    
    .ticker-item {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      margin-right: 2.5rem;
      font-size: 0.85rem;
    }
    
    .ticker-item .sym {
      font-weight: 600;
      color: var(--miami-cyan);
    }
    
    .ticker-item .price {
      font-family: 'JetBrains Mono', monospace;
    }
    
    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      bottom: 5rem;
      right: 2rem;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 1rem 1.5rem;
      transform: translateX(calc(100% + 3rem));
      transition: transform 0.3s;
      z-index: 1001;
    }
    
    .toast.show { transform: translateX(0); }
    .toast.success { border-color: var(--green); }
    .toast.error { border-color: var(--red); }
    
    /* ===== MARKET MAKER ===== */
    .mm-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .mm-header h1 {
      font-size: 2.5rem;
      font-weight: 900;
      margin-bottom: 0.5rem;
      background: linear-gradient(135deg, var(--miami-pink), var(--miami-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .mm-header p {
      color: var(--text-secondary);
      font-size: 1.1rem;
    }
    
    .mm-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem;
    }
    
    .mm-card {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      border: 1px solid var(--card-border);
      padding: 1.5rem;
    }
    
    .mm-card.full-width {
      grid-column: 1 / -1;
    }
    
    .mm-card h2 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }
    
    .mm-desc {
      color: var(--text-secondary);
      font-size: 0.9rem;
      margin-bottom: 1.5rem;
    }
    
    .mm-select-token,
    .mm-deposit-input {
      margin-bottom: 1.5rem;
    }
    
    .mm-select-token label,
    .mm-deposit-input label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--text-secondary);
    }
    
    .mm-dropdown,
    .mm-deposit-input input {
      width: 100%;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 0.75rem 1rem;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 1rem;
    }
    
    .mm-dropdown:focus,
    .mm-deposit-input input:focus {
      outline: none;
      border-color: var(--miami-cyan);
    }
    
    .mm-quick-amounts {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .mm-quick-amounts button {
      background: rgba(0,255,136,0.1);
      border: 1px solid var(--green);
      color: var(--green);
      padding: 0.5rem;
      border-radius: 8px;
      font-family: 'JetBrains Mono', monospace;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .mm-quick-amounts button:hover {
      background: var(--green);
      color: var(--bg-primary);
    }
    
    .mm-token-info {
      background: rgba(0,0,0,0.2);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1.5rem;
    }
    
    .mm-stat {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--card-border);
    }
    
    .mm-stat:last-child {
      border-bottom: none;
    }
    
    .mm-stat span:first-child {
      color: var(--text-muted);
    }
    
    .mm-stat span:last-child {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
      color: var(--matrix-green);
    }
    
    .mm-btn {
      width: 100%;
      padding: 1rem;
      border: none;
      border-radius: 12px;
      font-family: inherit;
      font-weight: 700;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .mm-btn.primary {
      background: linear-gradient(135deg, var(--green), #00cc77);
      color: var(--bg-primary);
      box-shadow: 0 4px 20px rgba(0,255,136,0.3);
    }
    
    .mm-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 30px rgba(0,255,136,0.4);
    }
    
    .mm-strategy-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .mm-strategy-option {
      background: rgba(0,0,0,0.2);
      border: 2px solid var(--card-border);
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .mm-strategy-option:hover {
      border-color: var(--miami-cyan);
      background: rgba(0,212,255,0.05);
    }
    
    .mm-strategy-option.active {
      border-color: var(--matrix-green);
      background: rgba(0,255,136,0.1);
    }
    
    .mm-strategy-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }
    
    .mm-strategy-icon {
      font-size: 2rem;
    }
    
    .mm-strategy-header h3 {
      font-size: 1.1rem;
      margin-bottom: 0.25rem;
    }
    
    .mm-strategy-header p {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .mm-strategy-stats {
      display: flex;
      gap: 1rem;
      font-size: 0.8rem;
      color: var(--text-muted);
    }
    
    .mm-strategy-params {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid var(--card-border);
    }
    
    .mm-strategy-params h4 {
      margin-bottom: 1rem;
    }
    
    .mm-param {
      margin-bottom: 1rem;
    }
    
    .mm-param label {
      display: block;
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }
    
    .mm-param input {
      width: 100%;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 0.5rem;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
    }
    
    .mm-empty-state {
      text-align: center;
      padding: 3rem 1rem;
    }
    
    .mm-empty-state p {
      color: var(--text-secondary);
      margin: 0.5rem 0;
    }
    
    .mm-positions table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .mm-positions th,
    .mm-positions td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 1px solid var(--card-border);
    }
    
    .mm-positions th {
      color: var(--text-muted);
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .mm-strategy-details h4 {
      font-size: 1rem;
      margin: 1rem 0 0.5rem;
      color: var(--text-primary);
    }
    
    .mm-strategy-details ul li strong {
      color: var(--text-primary);
    }
    
    /* ===== PROFILE PAGE ===== */
    .profile-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }
    
    .profile-header {
      text-align: center;
      margin-bottom: 3rem;
    }
    
    .profile-header h1 {
      font-size: 2.5rem;
      font-weight: 800;
      margin-bottom: 0.5rem;
      background: linear-gradient(135deg, var(--miami-pink), var(--miami-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .profile-header p {
      color: var(--text-secondary);
      font-size: 1.1rem;
    }
    
    .profile-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 1.5rem;
    }
    
    .profile-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 0;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    
    .profile-card:hover {
      border-color: rgba(255,255,255,0.12);
      transform: translateY(-2px);
    }
    
    .profile-card.full-width {
      grid-column: 1 / -1;
    }
    
    .profile-card-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--card-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .profile-card-header h2 {
      font-size: 1.3rem;
      font-weight: 700;
      margin: 0;
    }
    
    .profile-card-body {
      padding: 1.5rem;
    }
    
    .wallet-info {
      margin-bottom: 1rem;
    }
    
    .wallet-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .wallet-row:last-child {
      border-bottom: none;
    }
    
    .wallet-label {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }
    
    .wallet-value {
      color: var(--text-primary);
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      word-break: break-all;
      text-align: right;
      max-width: 60%;
    }
    
    .wallet-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      margin: 1.5rem 0;
    }
    
    .wallet-disclosure {
      background: rgba(0,212,255,0.05);
      border: 1px solid rgba(0,212,255,0.2);
      border-radius: 8px;
      padding: 0.75rem;
      margin: 1rem 0;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .disclosure-icon {
      font-size: 1.2rem;
      flex-shrink: 0;
    }
    
    .disclosure-text {
      color: var(--text-secondary);
      font-size: 0.85rem;
      line-height: 1.4;
    }
    
    .transfer-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }
    
    .transfer-tab {
      flex: 1;
      padding: 0.75rem;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      color: var(--text-secondary);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .transfer-tab:hover {
      background: rgba(255,255,255,0.08);
      color: var(--text-primary);
    }
    
    .transfer-tab.active {
      background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
      border: 2px solid transparent;
      background-image: 
        linear-gradient(135deg, #1a1a1a, #2d2d2d),
        linear-gradient(135deg, var(--miami-pink), var(--miami-cyan));
      background-origin: border-box;
      background-clip: padding-box, border-box;
      color: var(--text-primary);
    }
    
    .transfer-content label {
      display: block;
      color: var(--text-secondary);
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    
    .address-display {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 1rem;
      margin: 0.5rem 0;
    }
    
    .address-display span {
      flex: 1;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      word-break: break-all;
      color: var(--text-primary);
    }
    
    .copy-btn {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    
    .copy-btn:hover {
      background: rgba(255,255,255,0.15);
      transform: scale(1.05);
    }
    
    .transfer-note {
      color: var(--text-muted);
      font-size: 0.85rem;
      margin-top: 0.75rem;
      font-style: italic;
    }
    
    .profile-input {
      width: 100%;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 0.75rem;
      color: var(--text-primary);
      font-size: 0.95rem;
      font-family: 'JetBrains Mono', monospace;
      transition: all 0.2s;
    }
    
    .profile-input:focus {
      outline: none;
      border-color: var(--miami-cyan);
      box-shadow: 0 0 0 2px rgba(0,212,255,0.1);
    }
    
    .profile-btn {
      font-family: inherit;
      padding: 0.75rem 1.5rem;
      border-radius: 10px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
    }
    
    .profile-btn.primary {
      background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
      color: white;
      background-image: 
        linear-gradient(135deg, #1a1a1a, #2d2d2d),
        linear-gradient(135deg, var(--miami-pink), var(--miami-cyan));
      background-origin: border-box;
      background-clip: padding-box, border-box;
    }
    
    .profile-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0,212,255,0.3);
    }
    
    .profile-btn.secondary {
      background: rgba(255,255,255,0.05);
      color: var(--text-primary);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .profile-btn.secondary:hover {
      background: rgba(255,255,255,0.08);
    }
    
    .holdings-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .holdings-empty {
      text-align: center;
      color: var(--text-secondary);
      padding: 2rem;
      font-style: italic;
    }
    
    .holding-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.05);
      border-radius: 10px;
      transition: all 0.2s;
    }
    
    .holding-item:hover {
      background: rgba(255,255,255,0.04);
      border-color: rgba(255,255,255,0.1);
    }
    
    .holding-info {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .holding-icon {
      font-size: 2rem;
    }
    
    .holding-details h3 {
      margin: 0 0 0.25rem 0;
      font-size: 1.1rem;
      color: var(--text-primary);
    }
    
    .holding-details p {
      margin: 0;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .holding-balance {
      text-align: right;
    }
    
    .holding-amount {
      font-size: 1.2rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-primary);
      display: block;
      margin-bottom: 0.25rem;
    }
    
    .holding-usd {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }
    
    .mm-positions-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .mm-position-item {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 1rem;
      transition: all 0.2s;
    }
    
    .mm-position-item:hover {
      background: rgba(255,255,255,0.04);
      border-color: rgba(255,255,255,0.1);
    }
    
    .mm-position-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }
    
    .mm-position-token {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--text-primary);
    }
    
    .mm-position-status {
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
    }
    
    .mm-position-status.active {
      background: rgba(0,255,136,0.1);
      color: var(--green);
      border: 1px solid var(--green);
    }
    
    .mm-position-status.pending {
      background: rgba(255,217,61,0.1);
      color: var(--yellow);
      border: 1px solid var(--yellow);
    }
    
    .mm-position-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
    }
    
    .mm-position-stat {
      display: flex;
      flex-direction: column;
    }
    
    .mm-position-stat-label {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-bottom: 0.25rem;
    }
    
    .mm-position-stat-value {
      font-size: 1rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-primary);
    }
    
    .mm-position-stat-value.positive {
      color: var(--green);
    }
    
    .mm-position-stat-value.negative {
      color: var(--red);
    }
    
    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255,255,255,0.1);
      transition: 0.3s;
      border-radius: 26px;
      border: 1px solid var(--card-border);
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: var(--text-muted);
      transition: 0.3s;
      border-radius: 50%;
    }
    
    .toggle-switch input:checked + .toggle-slider {
      background: linear-gradient(135deg, var(--green), #00cc77);
      border-color: var(--green);
    }
    
    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(24px);
      background-color: white;
    }
    
    /* ===== RESPONSIVE ===== */
    @media (max-width: 1024px) {
      .trade-grid { grid-template-columns: 1fr; }
      .trade-panel { order: -1; }
    }
    
    @media (max-width: 768px) {
      .header { flex-wrap: wrap; gap: 1rem; }
      .nav { display: none; }
      .lottery-banner { flex-wrap: wrap; gap: 1rem; padding: 0.75rem 1rem; }
      .page { padding: 1rem; }
      .quick-amounts { grid-template-columns: repeat(2, 1fr); }
    }
  

/* ===== RADPAD ===== */
    .radpad-header {
      text-align: center;
      margin-bottom: 3rem;
    }
    
    .radpad-header h1 {
      font-size: 3rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--miami-pink), var(--miami-cyan), var(--miami-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
    }
    
    .radpad-header p {
      font-size: 1.1rem;
      color: var(--text-secondary);
    }
    
    .etch-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
    }
    
    .etch-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 2rem;
      backdrop-filter: blur(20px);
    }
    
    .etch-card h2 {
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
      color: var(--text-primary);
    }
    
    .form-group {
      margin-bottom: 1.5rem;
    }
    
    .form-group label {
      display: block;
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      font-weight: 500;
    }
    
    .form-group input,
    .form-group textarea {
      width: 100%;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      color: var(--text-primary);
      font-family: 'Inter', sans-serif;
      font-size: 0.95rem;
      transition: all 0.2s ease;
    }
    
    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: var(--miami-cyan);
      box-shadow: 0 0 0 3px rgba(0,212,255,0.1);
    }
    
    .form-group textarea {
      resize: vertical;
      min-height: 100px;
    }
    
    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }
    
    .slider-group {
      margin-bottom: 1.5rem;
    }
    
    .slider-group label {
      display: block;
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      font-weight: 500;
    }
    
    .slider-value {
      float: right;
      color: var(--miami-cyan);
      font-weight: 600;
    }
    
    .slider-group input[type="range"] {
      width: 100%;
      height: 6px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      outline: none;
      -webkit-appearance: none;
    }
    
    .slider-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: var(--miami-cyan);
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 2px 10px rgba(0,212,255,0.5);
    }
    
    .slider-group input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: var(--miami-cyan);
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 2px 10px rgba(0,212,255,0.5);
      border: none;
    }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
    }
    
    .checkbox-group input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }
    
    .checkbox-group label {
      margin: 0;
      cursor: pointer;
      user-select: none;
    }
    
    .etch-preview {
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }
    
    .etch-preview h3 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: var(--miami-cyan);
    }
    
    .preview-item {
      display: flex;
      justify-content: space-between;
      padding: 0.75rem 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .preview-item:last-child {
      border-bottom: none;
    }
    
    .preview-item .label {
      color: var(--text-secondary);
    }
    
    .preview-item .value {
      color: var(--text-primary);
      font-weight: 600;
    }
    
    .etch-btn {
      width: 100%;
      background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(255,255,255,0.1));
      border: 2px solid transparent;
      border-image: linear-gradient(135deg, var(--miami-pink), var(--miami-cyan), var(--miami-purple)) 1;
      color: var(--text-primary);
      padding: 1rem 2rem;
      border-radius: 12px;
      font-weight: 700;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .etch-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(255,45,146,0.3);
    }
    
    .etch-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .etch-info {
      background: rgba(0,212,255,0.1);
      border: 1px solid rgba(0,212,255,0.3);
      border-radius: 8px;
      padding: 1rem;
      margin-top: 1rem;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }
    
    .etch-list {
      margin-top: 3rem;
    }
    
    .etch-list h2 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      text-align: center;
    }
    
    .etch-items {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
    }
    
    .etch-item {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 1.5rem;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .etch-item:hover {
      transform: translateY(-4px);
      box-shadow: 0 10px 30px rgba(255,45,146,0.2);
    }
    
    .etch-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }
    
    .etch-item-name {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--miami-cyan);
    }
    
    .etch-item-symbol {
      background: rgba(255,45,146,0.2);
      border: 1px solid var(--miami-pink);
      padding: 0.25rem 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .etch-item-description {
      color: var(--text-secondary);
      font-size: 0.9rem;
      margin-bottom: 1rem;
      line-height: 1.5;
    }
    
    .etch-item-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }
    
    .etch-item-stat {
      background: rgba(0,0,0,0.3);
      padding: 0.5rem;
      border-radius: 6px;
    }
    
    .etch-item-stat .label {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: block;
      margin-bottom: 0.25rem;
    }
    
    .etch-item-stat .value {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--matrix-green);
    }
    
    .etch-item-socials {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    
    .social-link {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      color: var(--text-secondary);
      text-decoration: none;
      transition: all 0.2s ease;
    }
    
    .social-link:hover {
      background: rgba(0,212,255,0.1);
      border-color: var(--miami-cyan);
      color: var(--miami-cyan);
    }
  </style>
</head>
<body>
  <div class="bg-gradient"></div>
  <div class="bg-grid"></div>
  
  <!-- Lottery Banner -->
  <div class="lottery-banner">
    <div class="lottery-timer">
      <span class="icon"></span>
      <span>NEXT WINNER IN</span>
      <div class="lottery-slots">
        <span class="slot-digit" id="hr1">0</span>
        <span class="slot-digit" id="hr2">0</span>
        <span>:</span>
        <span class="slot-digit" id="min1">0</span>
        <span class="slot-digit" id="min2">0</span>
        <span>:</span>
        <span class="slot-digit" id="sec1">0</span>
        <span class="slot-digit" id="sec2">0</span>
      </div>
    </div>
    <div class="lottery-prize">
      <span> JACKPOT:</span>
      <span class="amount" id="jackpot">0.00125 BTC</span>
    </div>
    <div style="color:var(--text-secondary);font-size:0.8rem">
      0.25% of fees  Random trader wins!
    </div>
  </div>

  <!-- Header -->
  <header class="header">
    <div class="logo">
      <div class="logo-icon">
        <svg viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
          <!-- Flask outline -->
          <path d="M15 4h10v2h-10zM15 6v10l-7 16c-1 2.5 1 5 4 5h16c3 0 5-2.5 4-5l-7-16V6" 
                stroke="#1a1a1a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <!-- Green liquid fill -->
          <path d="M10 28l5-10h10l5 10c1 2-0.5 4-2.5 4h-15c-2 0-3.5-2-2.5-4z" fill="url(#greenLiquid)"/>
          <!-- Bubbles -->
          <circle cx="16" cy="30" r="1.5" fill="#7fff7f">
            <animate attributeName="cy" values="30;26;30" dur="1.5s" repeatCount="indefinite"/>
          </circle>
          <circle cx="24" cy="28" r="2" fill="#7fff7f">
            <animate attributeName="cy" values="28;23;28" dur="2s" repeatCount="indefinite"/>
          </circle>
          <circle cx="20" cy="32" r="1.2" fill="#7fff7f">
            <animate attributeName="cy" values="32;27;32" dur="1.8s" repeatCount="indefinite"/>
          </circle>
          <!-- Highlight -->
          <path d="M12 26l2 6" stroke="rgba(255,255,255,0.4)" stroke-width="1.5" stroke-linecap="round"/>
          <defs>
            <linearGradient id="greenLiquid" x1="20" y1="18" x2="20" y2="36" gradientUnits="userSpaceOnUse">
              <stop offset="0%" stop-color="#00ff66"/>
              <stop offset="100%" stop-color="#00aa44"/>
            </linearGradient>
          </defs>
        </svg>
      </div>
      <span class="logo-text"><span class="rad">Rad</span><span class="labs">Labs</span></span>
    </div>
    
    <nav class="nav">
      <a href="#" class="active" data-page="trade">Trade</a>
      <a href="#" data-page="tokens">Tokens</a>
      <a href="#" data-page="radpad">RadPad</a>
      <a href="#" data-page="market-maker">Market Maker</a>
      <a href="#" data-page="profile">Profile</a>
    </nav>
    
    <div class="balance-display" id="balanceDisplay" style="display: none;">
      <div class="balance-item">
        <span class="balance-label">BTC Wallet</span>
        <span class="balance-value" id="btcBalance">0.0000 BTC</span>
      </div>
      <div class="balance-item">
        <span class="balance-label">RadFi Trading</span>
        <span class="balance-value" id="tradingBalance">-- BTC</span>
      </div>
      <div class="balance-item">
        <span class="balance-label">Positions</span>
        <span class="balance-value" id="positionCount">0</span>
      </div>
    </div>
    
    <button class="connect-btn" id="connectBtn" onclick="connectWallet()">Connect Wallet</button>
  </header>

  <!-- TRADE PAGE -->
  <div class="page active" id="page-trade">
    <div class="trade-grid">
      <div class="chart-card">
        <div class="chart-header">
          <div class="token-display">
            <div class="token-img" id="chartImg"></div>
            <div class="token-meta">
              <h2><span id="chartName">BOTT</span> <span class="rune" id="chartRune">BABYBOTTLE</span></h2>
              <div class="token-stats">
                <span>MCap: <span class="val" id="chartMcap">$2.19M</span></span>
                <span>Vol: <span class="val" id="chartVol">$7.9K</span></span>
                <span>Liq: <span class="val" id="chartLiq">$4.3M</span></span>
              </div>
            </div>
          </div>
          <div class="price-box">
            <div class="price" id="chartPrice">2.81 sats</div>
            <div class="price-usd" id="chartUsd"> $0.00219</div>
            <div class="change up" id="chartChange">+5.2%</div>
          </div>
        </div>
        
        <div class="chart-container">
          <video id="bgVideo" class="chart-video-bg" autoplay muted loop playsinline>
            <source src="assets/powell.mp4" type="video/mp4">
          </video>
          <button class="mute-btn" id="muteBtn" onclick="toggleMute()"></button>
          <div id="tvChart"></div>
        </div>
        
        <div class="chart-controls">
          <div class="chart-timeframes">
            <button class="tf-btn" data-tf="1">1m</button>
            <button class="tf-btn" data-tf="5">5m</button>
            <button class="tf-btn active" data-tf="15">15m</button>
            <button class="tf-btn" data-tf="60">1H</button>
            <button class="tf-btn" data-tf="240">4H</button>
            <button class="tf-btn" data-tf="1440">1D</button>
          </div>
          <div class="chart-type-btns">
            <button class="chart-type-btn" onclick="setChartType('Line')" title="Line"></button>
            <button class="chart-type-btn active" onclick="setChartType('Candle')" title="Candles"></button>
          </div>
        </div>
      </div>

      <div class="trade-panel">
        <div class="panel-card">
          <div class="panel-tabs">
            <button class="panel-tab active buy" onclick="setTradeMode('buy')">Buy</button>
            <button class="panel-tab sell" onclick="setTradeMode('sell')">Sell</button>
          </div>
          
          <div class="quick-amounts">
            <button class="quick-btn" onclick="setAmt(0.0001)">0.0001</button>
            <button class="quick-btn" onclick="setAmt(0.0005)">0.0005</button>
            <button class="quick-btn" onclick="setAmt(0.001)">0.001</button>
            <button class="quick-btn" onclick="setAmt(0.003)">0.003</button>
          </div>
          
          <div class="input-group">
            <div class="input-label">
              <span>You Pay</span>
              <span>Balance: <span id="fromBal">0.00</span></span>
            </div>
            <div class="input-row">
              <input type="number" class="input-field" id="fromAmt" placeholder="0.0" oninput="calcQuote()">
              <div class="token-select" onclick="openTokenModal('from')">
                <div class="mini-img" style="background:linear-gradient(135deg,#f7931a,#ff6600)"></div>
                <span id="fromSym">BTC</span>
                <span></span>
              </div>
            </div>
          </div>
          
          <div class="swap-arrow">
            <button onclick="flipTokens()"></button>
          </div>
          
          <div class="input-group">
            <div class="input-label">
              <span>You Receive</span>
              <span>Balance: <span id="toBal">0.00</span></span>
            </div>
            <div class="input-row">
              <input type="number" class="input-field" id="toAmt" placeholder="0.0" readonly>
              <div class="token-select" onclick="openTokenModal('to')">
                <div class="mini-img" id="toMiniImg"></div>
                <span id="toSym">BOTT</span>
                <span></span>
              </div>
            </div>
          </div>
          
          <div class="health-row">
            <span style="color:var(--text-muted);font-size:0.85rem">Liquidity Health</span>
            <span class="health-badge">HIGH</span>
          </div>
          
          <div class="trade-info">
            <div class="info-row"><span class="label">Rate</span><span class="value" id="rate">1 BTC = 355,618 BOTT</span></div>
            <div class="info-row"><span class="label">Price Impact</span><span class="value" id="impact">~0.15%</span></div>
            <div class="info-row"><span class="label">Platform Fee (1%)</span><span class="value fee" id="fee">0.00001 BTC</span></div>
            <div class="info-row"><span class="label">Network Fee</span><span class="value">~500 sats</span></div>
          </div>
          
          <button class="trade-btn buy" id="tradeBtn" onclick="handleTrade()">Connect Wallet</button>
        </div>
      </div>
    </div>

    <div class="token-list-card">
      <div class="list-header">
        <h3><span class="live-dot"></span> RADFI TOKENS (LIVE)</h3>
        <div class="search-box">
          <span></span>
          <input type="text" placeholder="Search..." oninput="filterTable(this.value)">
        </div>
      </div>
      <table class="token-table">
        <thead>
          <tr>
            <th>#</th>
            <th>Token</th>
            <th>Price (sats)</th>
            <th>Price (USD)</th>
            <th>24h</th>
            <th>Market Cap</th>
            <th>Volume 24h</th>
          </tr>
        </thead>
        <tbody id="tokenTbody">
          <tr><td colspan="7" style="text-align:center;padding:2rem;color:var(--text-muted)">Loading...</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- TOKENS PAGE -->
  <div class="page" id="page-tokens">
    <div style="text-align:center;padding:2rem 0">
      <h1 style="font-size:2.5rem;font-weight:800;background:linear-gradient(90deg,var(--miami-pink),var(--miami-cyan));-webkit-background-clip:text;-webkit-text-fill-color:transparent">All RadFi Tokens</h1>
      <p style="color:var(--text-secondary);margin-top:0.5rem">Live data from RadFi production API</p>
    </div>
    <div class="token-list-card" style="margin-top:0">
      <div class="list-header">
        <h3>Complete Token List</h3>
        <div class="search-box">
          <span></span>
          <input type="text" placeholder="Search..." oninput="filterAllTable(this.value)">
        </div>
      </div>
      <table class="token-table">
        <thead>
          <tr><th>#</th><th>Token</th><th>Price (sats)</th><th>Price (USD)</th><th>24h</th><th>MCap</th><th>Vol 24h</th><th>All Time Vol</th></tr>
        </thead>
        <tbody id="allTokensTbody"></tbody>
      </table>
    </div>
  </div>

    <!-- RADPAD PAGE -->
  <div class="page" id="page-radpad">
    <div class="radpad-header">
      <h1> RadPad</h1>
      <p>Launch your Rune on Bitcoin with instant liquidity</p>
    </div>
    
    <div class="etch-grid">
      <!-- Left: Rune Details -->
      <div class="etch-card">
        <h2>Rune Details</h2>
        
        <div class="form-group">
          <label>Rune Name *</label>
          <input type="text" id="runeName" placeholder="UNCOMMONGOODS" 
                 onkeyup="updatePreview()">
        </div>
        
        <div class="form-row">
          <div class="form-group">
            <label>Symbol *</label>
            <input type="text" id="symbol" placeholder="UG" maxlength="4"
                   onkeyup="updatePreview()">
          </div>
          
          <div class="form-group">
            <label>Display Ticker</label>
            <input type="text" id="displayTicker" placeholder="UG"
                   onkeyup="updatePreview()">
          </div>
        </div>
        
        <div class="form-group">
          <label>Description *</label>
          <textarea id="description" placeholder="Describe your Rune project..."
                    onkeyup="updatePreview()"></textarea>
        </div>
        
        <div class="form-group">
          <label>Inscription Type</label>
          <input type="text" id="inscriptionType" value="text/plain" readonly>
        </div>
        
        <div class="form-group">
          <label>Inscription Content</label>
          <textarea id="inscriptionContent" placeholder="Additional inscription data..."
                    onkeyup="updatePreview()"></textarea>
        </div>
        
        <div class="form-row">
          <div class="form-group">
            <label>Twitter/X</label>
            <input type="text" id="socialX" placeholder="https://x.com/yourproject"
                   onkeyup="updatePreview()">
          </div>
          
          <div class="form-group">
            <label>Telegram</label>
            <input type="text" id="socialTg" placeholder="https://t.me/yourproject"
                   onkeyup="updatePreview()">
          </div>
        </div>
      </div>
      
      <!-- Right: Launch Parameters -->
      <div class="etch-card">
        <h2>Launch Parameters</h2>
        
        <div class="slider-group">
          <label>
            Fee Tier
            <span class="slider-value" id="feeTierVal">1.0%</span>
          </label>
          <input type="range" id="feeTier" min="5000" max="100000" step="5000" value="10000"
                 oninput="updateSliders(); updatePreview();">
          <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;">
            Trading fee percentage for your token's liquidity pool
          </div>
        </div>
        
        <div class="slider-group">
          <label>
            Liquidity Allocation
            <span class="slider-value" id="lpRateVal">20%</span>
          </label>
          <input type="range" id="lpRate" min="0" max="100" step="5" value="20"
                 oninput="updateSliders(); updatePreview();">
          <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;">
            % of raised BTC going to liquidity (rest goes to creator)
          </div>
        </div>
        
        <div class="slider-group">
          <label>
            Diamond Hands Reward
            <span class="slider-value" id="rewardRateVal">50%</span>
          </label>
          <input type="range" id="rewardRate" min="0" max="100" step="5" value="50"
                 oninput="updateSliders(); updatePreview();">
          <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;">
            Long-term holder reward (% of available 66.67% rewards)
          </div>
        </div>
        
        <div class="checkbox-group">
          <input type="checkbox" id="blockWithdrawals" onchange="updatePreview()">
          <label for="blockWithdrawals">
            Block external withdrawals (only internal RadFi transfers allowed)
          </label>
        </div>
        
        <div class="etch-preview">
          <h3>Launch Preview</h3>
          <div class="preview-item">
            <span class="label">Rune Name:</span>
            <span class="value" id="prevName">-</span>
          </div>
          <div class="preview-item">
            <span class="label">Symbol:</span>
            <span class="value" id="prevSymbol">-</span>
          </div>
          <div class="preview-item">
            <span class="label">Fee Tier:</span>
            <span class="value" id="prevFee">1.0%</span>
          </div>
          <div class="preview-item">
            <span class="label">LP Allocation:</span>
            <span class="value" id="prevLP">20%</span>
          </div>
          <div class="preview-item">
            <span class="label">Creator Gets:</span>
            <span class="value" id="prevCreator">80%</span>
          </div>
          <div class="preview-item">
            <span class="label">Diamond Reward:</span>
            <span class="value" id="prevReward">33.33%</span>
          </div>
          <div class="preview-item">
            <span class="label">Withdrawals:</span>
            <span class="value" id="prevWithdraw">Allowed</span>
          </div>
        </div>
        
        <button class="etch-btn" onclick="launchRune()">
          Launch Rune
        </button>
        
        <div class="etch-info">
           Connect your wallet to etch a new Rune. You'll need BTC for the inscription and etching fees.
        </div>
      </div>
    </div>
    
    <!-- Recently Launched -->
    <div class="etch-list">
      <h2>Recently Launched</h2>
      <div class="etch-items" id="etchedRunes">
        <div style="text-align: center; padding: 2rem; grid-column: 1/-1; color: var(--text-secondary);">
          Loading recently etched Runes...
        </div>
      </div>
    </div>
  </div>

  <!-- MARKET MAKER PAGE -->
  <div class="page" id="page-market-maker">
    <div class="mm-header">
      <h1> RadLabs Market Maker</h1>
      <p>Provide liquidity and earn fees through automated market making on RadFi pools</p>
    </div>

    <div class="mm-grid">
      <!-- Deposit Card -->
      <div class="mm-card">
        <h2> Deploy Capital</h2>
        <p class="mm-desc">Choose a token and deposit funds to start market making</p>
        
        <div class="mm-select-token">
          <label>Select Token to Market Make</label>
          <select id="mmTokenSelect" class="mm-dropdown">
            <option value="">-- Choose Token --</option>
          </select>
        </div>

        <div class="mm-token-info" id="mmTokenInfo" style="display:none">
          <div class="mm-stat">
            <span>Market Cap:</span>
            <span id="mmTokenMcap">--</span>
          </div>
          <div class="mm-stat">
            <span>24h Volume:</span>
            <span id="mmTokenVol">--</span>
          </div>
          <div class="mm-stat">
            <span>RadFi Pool TVL:</span>
            <span id="mmPoolTVL">--</span>
          </div>
        </div>

        <div class="mm-deposit-input">
          <label>Deposit Amount (BTC)</label>
          <input type="number" id="mmDepositAmount" placeholder="0.01" min="0.001" step="0.001" oninput="updateMMUSD()">
          <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.5rem;">
             $<span id="mmDepositUSD">0</span> USD    <span style="color: var(--miami-orange);">Min: 0.001 BTC</span>
          </div>
          <div class="mm-quick-amounts">
            <button onclick="setMMAmount(0.01)">0.01</button>
            <button onclick="setMMAmount(0.05)">0.05</button>
            <button onclick="setMMAmount(0.1)">0.1</button>
            <button onclick="setMMAmount(0.5)">0.5</button>
          </div>
        </div>

        <button class="mm-btn primary" onclick="depositToMM()">Deposit & Start MM</button>
      </div>

      <!-- Strategy Card -->
      <div class="mm-card">
        <h2> RadFi LP Strategy</h2>
        <p class="mm-desc">Automated liquidity provision with active rebalancing</p>

        <div class="mm-strategy-list">
          <div class="mm-strategy-option active" onclick="selectMMStrategy('radfi-lp')">
            <div class="mm-strategy-header">
              <span class="mm-strategy-icon"></span>
              <div>
                <h3>RadFi LP Market Making</h3>
                <p>Provide liquidity and earn fees on all swaps</p>
              </div>
            </div>
            <div class="mm-strategy-stats">
              <span style="color: var(--green); font-weight: 600;">Estimated APY: 23-32%</span>
            </div>
          </div>
        </div>

        <div class="mm-strategy-details">
          <h4>How It Works</h4>
          <ul style="list-style: none; padding: 0; margin: 1rem 0;">
            <li style="padding: 0.5rem 0;"> <strong>Pool Fees:</strong> Earn fees on every trade through the pool</li>
            <li style="padding: 0.5rem 0;"> <strong>Active Management:</strong> Automated rebalancing to optimize returns</li>
            <li style="padding: 0.5rem 0;"> <strong>RadFi Native:</strong> Low transaction costs enable frequent optimization</li>
            <li style="padding: 0.5rem 0;"> <strong>Risk:</strong> Impermanent loss up to -25% on large price movements</li>
          </ul>
          <div class="mm-stat" style="background: rgba(0,255,136,0.1); padding: 1rem; border-radius: 8px; margin-top: 1rem;">
            <span style="font-size: 0.9rem; color: var(--text-secondary);">Based on backtested historical data</span>
            <span style="font-size: 1.2rem; font-weight: 700; color: var(--green);">Real returns vary by pool</span>
          </div>
        </div>

        <div class="mm-toggle" style="margin-top: 1.5rem; padding: 1rem; background: rgba(255,255,255,0.03); border-radius: 8px;">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <h4 style="margin: 0;">Auto-Rebalance</h4>
              <p style="margin: 0.25rem 0 0; font-size: 0.85rem; color: var(--text-secondary);">Monitor and rebalance every 10 seconds</p>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="mmAutoRebalance" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>
      </div>

      <!-- Active Positions Card -->
      <div class="mm-card full-width">
        <h2> Your Active Positions</h2>
        <div class="mm-positions" id="mmPositions">
          <div class="mm-empty-state">
            <span style="font-size:3rem"></span>
            <p>No active market making positions</p>
            <p class="mm-desc">Deploy capital above to get started</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Wallet Modal -->
  <div class="modal-overlay" id="walletModal">
    <div class="modal">
      <h3>Connect Wallet</h3>
      <div class="wallet-option" onclick="doConnect('unisat')">
        <img src="https://unisat.io/favicon.ico" alt="Unisat">
        <div><div class="name">Unisat</div><div class="desc">Bitcoin & Ordinals</div></div>
      </div>
      <div class="wallet-option" onclick="doConnect('xverse')">
        <img src="https://www.xverse.app/favicon.ico" alt="Xverse">
        <div><div class="name">Xverse</div><div class="desc">Bitcoin & Stacks</div></div>
      </div>
      <div class="wallet-option" onclick="doConnect('okx')">
        <img src="https://www.okx.com/favicon.ico" alt="OKX">
        <div><div class="name">OKX Wallet</div><div class="desc">Multi-chain</div></div>
      </div>
    </div>
  </div>

  <!-- Token Modal -->
  <div class="modal-overlay" id="tokenModal">
    <div class="modal">
      <h3>Select Token</h3>
      <div class="search-box" style="margin-bottom:1rem">
        <span></span>
        <input type="text" placeholder="Search..." oninput="filterModal(this.value)" style="width:100%">
      </div>
      <div id="tokenModalList" style="max-height:400px;overflow-y:auto"></div>
    </div>
  </div>

  <!-- PROFILE PAGE -->
  <div class="page" id="page-profile">
    <div class="profile-container">
      <div class="profile-header">
        <h1> Profile</h1>
        <p>Manage your wallets, balances, and positions</p>
      </div>

      <div class="profile-grid">
        <!-- Wallet Status Card -->
        <div class="profile-card">
          <div class="profile-card-header">
            <h2> Wallet Status</h2>
          </div>
          <div class="profile-card-body">
            <div class="wallet-info">
              <div class="wallet-row">
                <span class="wallet-label">Connected Wallet</span>
                <span class="wallet-value" id="profileConnectedWallet">Not connected</span>
              </div>
              <div class="wallet-row">
                <span class="wallet-label">BTC Balance</span>
                <span class="wallet-value" id="profileBTCBalance">-- BTC</span>
              </div>
            </div>

            <div class="wallet-divider"></div>

            <div class="wallet-info">
              <div class="wallet-row">
                <span class="wallet-label">RadFi Trading Wallet</span>
                <span class="wallet-value" id="profileTradingWallet">Not created</span>
              </div>
              <div class="wallet-disclosure">
                <span class="disclosure-icon"></span>
                <span class="disclosure-text">This is your RadFi 2-of-2 multisig trading wallet. Same as RadFi.co</span>
              </div>
              <div class="wallet-row">
                <span class="wallet-label">Trading Balance</span>
                <span class="wallet-value" id="profileTradingBalance">-- BTC</span>
              </div>
              <div id="createTradingWalletSection" style="display:none; margin-top: 1rem;">
                <button class="profile-btn primary" onclick="createTradingWallet()">Create Trading Wallet</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Send/Receive Card -->
        <div class="profile-card">
          <div class="profile-card-header">
            <h2> Send / Receive</h2>
          </div>
          <div class="profile-card-body">
            <div class="transfer-tabs">
              <button class="transfer-tab active" onclick="switchTransferTab('receive')">Receive</button>
              <button class="transfer-tab" onclick="switchTransferTab('send')">Send</button>
            </div>

            <div class="transfer-content" id="receiveTab">
              <div class="receive-section">
                <label>Your Trading Wallet Address</label>
                <div class="address-display">
                  <span id="receiveAddress">--</span>
                  <button class="copy-btn" onclick="copyAddress()"></button>
                </div>
                <p class="transfer-note">Send BTC or Runes to this address to fund your trading wallet</p>
              </div>
            </div>

            <div class="transfer-content" id="sendTab" style="display:none;">
              <div class="send-section">
                <label>Asset Type</label>
                <select id="sendAssetType" class="profile-input" onchange="updateSendForm()">
                  <option value="btc">Bitcoin (BTC)</option>
                  <option value="rune">Rune Token</option>
                </select>

                <div id="sendRuneSelector" style="display:none; margin-top: 1rem;">
                  <label>Select Rune</label>
                  <select id="sendRuneToken" class="profile-input">
                    <option value="">-- Choose Token --</option>
                  </select>
                </div>

                <label style="margin-top: 1rem;">Recipient Address</label>
                <input type="text" id="sendRecipient" class="profile-input" placeholder="bc1...">

                <label style="margin-top: 1rem;">Amount</label>
                <input type="number" id="sendAmount" class="profile-input" placeholder="0.001" step="0.00000001">

                <button class="profile-btn primary" style="margin-top: 1rem;" onclick="sendFunds()">Send</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Token Holdings Card -->
        <div class="profile-card full-width">
          <div class="profile-card-header">
            <h2> Token Holdings</h2>
            <button class="profile-btn secondary" onclick="refreshHoldings()"> Refresh</button>
          </div>
          <div class="profile-card-body">
            <div id="tokenHoldingsList" class="holdings-list">
              <p class="holdings-empty">Loading holdings...</p>
            </div>
          </div>
        </div>

        <!-- MM Positions Card -->
        <div class="profile-card full-width">
          <div class="profile-card-header">
            <h2> Market Maker Positions</h2>
            <button class="profile-btn secondary" onclick="refreshMMPositions()"> Refresh</button>
          </div>
          <div class="profile-card-body">
            <div id="mmPositionsList" class="mm-positions-list">
              <p class="holdings-empty">Loading positions...</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"><span id="toastMsg"></span></div>

  <script>
    // STATE
    const S = {
      tokens: [],
      etchedRunes: [],           // Recently etched runes for RadPad
      userAddress: null,          // User's wallet address (Xverse/Unisat/OKX)
      tradingAddress: null,       // RadFi trading wallet address (2-of-2 multisig)
      tradingWalletBalance: 0,    // Trading wallet balance in sats
      publicKey: null,            // User's public key
      walletType: null,           // 'unisat' | 'xverse' | 'okx'
      walletData: null,           // Full wallet object from RadFi
      hasWalletHistory: false,    // True if wallet was used on RadFi before
      accessToken: null,          // JWT access token
      refreshToken: null,         // JWT refresh token
      mode: 'buy',
      from: { symbol: 'BTC', tokenId: '0:0', priceInSats: 100000000 },
      to: null,
      selected: null,
      selectTarget: 'to',
      chart: null,
      candleSeries: null,
      lineSeries: null,
      chartType: 'Candle',
      timeframe: 15 // minutes per candle
    };
    
    // Global BTC price cache
    let btcPriceUSD = 100000; // Default fallback
    
    // Fetch real BTC price from CoinGecko
    async function fetchBTCPrice() {
      try {
        const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
        const data = await response.json();
        if (data.bitcoin && data.bitcoin.usd) {
          btcPriceUSD = data.bitcoin.usd;
          console.log('[Price] BTC price updated: $' + btcPriceUSD.toLocaleString());
          return btcPriceUSD;
        }
      } catch (error) {
        console.error('[Price] Failed to fetch BTC price:', error);
      }
      return btcPriceUSD;
    }

    // LOTTERY TIMER
    function updateLotteryTimer() {
      const now = new Date();
      const endOfDay = new Date(now);
      endOfDay.setHours(23, 59, 59, 999);
      const diff = endOfDay - now;
      
      const hrs = Math.floor(diff / 3600000);
      const mins = Math.floor((diff % 3600000) / 60000);
      const secs = Math.floor((diff % 60000) / 1000);
      
      document.getElementById('hr1').textContent = Math.floor(hrs / 10);
      document.getElementById('hr2').textContent = hrs % 10;
      document.getElementById('min1').textContent = Math.floor(mins / 10);
      document.getElementById('min2').textContent = mins % 10;
      document.getElementById('sec1').textContent = Math.floor(secs / 10);
      document.getElementById('sec2').textContent = secs % 10;
    }
    setInterval(updateLotteryTimer, 1000);
    updateLotteryTimer();

    // CRASH GAME
    let crashInterval = null;
    let crashMultiplier = 1.0;
    let crashBetPlaced = false;

    function placeCrashBet() {
      if (!S.userAddress) { connectWallet(); return; }
      if (crashBetPlaced) return;
      
      crashBetPlaced = true;
      crashMultiplier = 1.0;
      document.getElementById('cashoutBtn').disabled = false;
      
      crashInterval = setInterval(() => {
        crashMultiplier *= 1.01 + Math.random() * 0.02;
        document.getElementById('crashMultiplier').textContent = crashMultiplier.toFixed(2) + 'x';
        
        // Random crash
        if (Math.random() < 0.01 || crashMultiplier > 10) {
          clearInterval(crashInterval);
          document.getElementById('crashMultiplier').classList.add('crashed');
          document.getElementById('crashMultiplier').textContent = 'CRASHED!';
          document.getElementById('cashoutBtn').disabled = true;
          crashBetPlaced = false;
          
          setTimeout(() => {
            document.getElementById('crashMultiplier').classList.remove('crashed');
            document.getElementById('crashMultiplier').textContent = '1.00x';
          }, 2000);
        }
      }, 100);
    }

    function cashoutCrash() {
      if (!crashBetPlaced) return;
      clearInterval(crashInterval);
      crashBetPlaced = false;
      document.getElementById('cashoutBtn').disabled = true;
      
      const bet = parseFloat(document.getElementById('crashBet').value);
      const win = bet * crashMultiplier;
      toast(`Cashed out at ${crashMultiplier.toFixed(2)}x! Won ${win.toFixed(6)} BTC`, 'success');
    }

    // API
    const API = '';

    async function loadTokens() {
  try {
    console.log('[Tokens] Loading...');
    
    const tokensRes = await fetch(`${API}/api/tokens?pageSize=100&sort=-volume24h`);
    const tokensData = await tokensRes.json();
    
    if (!tokensData.data) {
      throw new Error('No token data received');
    }
    
    console.log('[Tokens] Fetching pools...');
    const poolsRes = await fetch(`${API}/api/pools?pageSize=200`);
    const poolsData = await poolsRes.json();
    
    // Create token1Id -> pool info mapping
    const poolMap = {};
    if (poolsData.data) {
      for (const pool of poolsData.data) {
        poolMap[pool.token1Id] = {
          poolId: pool._id,
          tvl: pool.tvl  // Already in USD!
        };
      }
      console.log('[Tokens] Mapped', Object.keys(poolMap).length, 'pools');
    }
    
    // Enrich tokens with pool data
    S.tokens = tokensData.data
      .filter(t => t.hasPool && !t.isTest)
      .map(t => {
        const poolInfo = poolMap[t.tokenId];
        return { 
          ...t, 
          poolId: poolInfo?.poolId || null,
          poolTVL: poolInfo?.tvl || null
        };
      });
    
    console.log('[Tokens] Loaded', S.tokens.length, 'tokens');
    console.log('[Tokens] Sample token:', S.tokens[0]?.symbol, 'poolId:', S.tokens[0]?.poolId);
    
    renderTable();
    
    if (S.tokens.length > 0) {
      selectToken(S.tokens[0]);
      S.to = S.tokens[0];
      updateToDisplay();
    }
  } catch (e) {
    console.error('[Tokens] Load error:', e);
    const tbody = document.getElementById('tokenTbody');
    if (tbody) {
      tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;padding:2rem;color:var(--red)">Error loading</td></tr>';
    }
  }
}

    // RENDER TABLE
    function renderTable() {
      const tbody = document.getElementById('tokenTbody');
      tbody.innerHTML = S.tokens.slice(0, 20).map((t, i) => tokenRow(t, i)).join('');
    }

    function renderAllTokens() {
      const tbody = document.getElementById('allTokensTbody');
      tbody.innerHTML = S.tokens.map((t, i) => tokenRowFull(t, i)).join('');
    }

    function tokenRow(t, i) {
      const name = t.displayTicker || t.symbol || '?';
      const rune = t.spacedRune || '';
      const sats = t.priceInSats || 0;
      const usd = t.price || 0;
      const change = ((t.priceChange24h || 0) - (t.price || 0)) / ((t.price || 1)) * 100;
      const changeDisplay = usd > 0 ? ((change >= 0 ? '+' : '') + change.toFixed(2) + '%') : '0%';
      const changeClass = change >= 0 ? 'up' : 'down';
      const mcap = t.marketCap || 0;
      const vol = t.volume24h || 0;
      
      return `
        <tr onclick='selectToken(${JSON.stringify(t).replace(/'/g, "\\'")})'>
          <td>${i + 1}</td>
          <td>
            <div class="token-cell">
              <div class="img">${t.symbol || '?'}</div>
              <div><div class="name">${name}</div><div class="rune">${rune}</div></div>
            </div>
          </td>
          <td class="mono green">${fmtSats(sats)}</td>
          <td class="mono">$${fmtNum(usd)}</td>
          <td class="mono ${changeClass}">${changeDisplay}</td>
          <td class="mono">$${fmtCompact(mcap)}</td>
          <td class="mono">$${fmtCompact(vol)}</td>
        </tr>
      `;
    }

    function tokenRowFull(t, i) {
      const name = t.displayTicker || t.symbol || '?';
      const rune = t.spacedRune || '';
      const sats = t.priceInSats || 0;
      const usd = t.price || 0;
      const change = ((t.priceChange24h || 0) - (t.price || 0)) / ((t.price || 1)) * 100;
      const changeDisplay = usd > 0 ? ((change >= 0 ? '+' : '') + change.toFixed(2) + '%') : '0%';
      const changeClass = change >= 0 ? 'up' : 'down';
      
      return `
        <tr onclick='selectTokenNav(${JSON.stringify(t).replace(/'/g, "\\'")})'>
          <td>${i + 1}</td>
          <td><div class="token-cell"><div class="img">${t.symbol || '?'}</div><div><div class="name">${name}</div><div class="rune">${rune}</div></div></div></td>
          <td class="mono green">${fmtSats(sats)}</td>
          <td class="mono">$${fmtNum(usd)}</td>
          <td class="mono ${changeClass}">${changeDisplay}</td>
          <td class="mono">$${fmtCompact(t.marketCap || 0)}</td>
          <td class="mono">$${fmtCompact(t.volume24h || 0)}</td>
          <td class="mono">$${fmtCompact(t.volumeAllTime || 0)}</td>
        </tr>
      `;
    }

    function selectTokenNav(t) {
      selectToken(t);
      navigate('trade');
    }

    function renderTicker() {
      const items = S.tokens.slice(0, 15).map(t => {
        const name = t.displayTicker || t.symbol || '?';
        const change = ((t.priceChange24h || 0) - (t.price || 0)) / ((t.price || 1)) * 100;
        const changeClass = change >= 0 ? 'up' : 'down';
        return `
          <span class="ticker-item">
            <span class="sym">${name}</span>
            <span class="price mono">$${fmtCompact(t.marketCap || 0)}</span>
            <span class="${changeClass}">${change >= 0 ? '+' : ''}${change.toFixed(2)}%</span>
          </span>
        `;
      }).join('');
      document.getElementById('ticker').innerHTML = items + items;
    }

    // TOKEN SELECTION
    function selectToken(t) {
      S.selected = t;
      S.to = t;
      updateToDisplay();
      
      const name = t.displayTicker || t.symbol || '?';
      const mcap = t.marketCap || 0;
      document.getElementById('chartImg').textContent = t.symbol || '?';
      document.getElementById('chartName').textContent = name;
      document.getElementById('chartRune').textContent = t.spacedRune || '';
      document.getElementById('chartMcap').textContent = '$' + fmtCompact(mcap);
      document.getElementById('chartVol').textContent = '$' + fmtCompact(t.volume24h || 0);
      document.getElementById('chartLiq').textContent = '$' + fmtCompact(t.volumeAllTime || 0);
      // Show market cap as "price" everywhere
      document.getElementById('chartPrice').textContent = '$' + fmtCompact(mcap);
      document.getElementById('chartUsd').textContent = 'Market Cap';
      
      const change = ((t.priceChange24h || 0) - (t.price || 0)) / ((t.price || 1)) * 100;
      const changeEl = document.getElementById('chartChange');
      changeEl.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
      changeEl.className = `change ${change >= 0 ? 'up' : 'down'}`;
      
      updateChart();
      calcQuote();
    }

    function updateToDisplay() {
      if (S.to) {
        const name = S.to.displayTicker || S.to.symbol || '?';
        document.getElementById('toSym').textContent = name;
        document.getElementById('toMiniImg').textContent = S.to.symbol || '?';
      }
    }

    // CHART (TradingView Lightweight)
    function initChart() {
      const container = document.getElementById('tvChart');
      S.chart = LightweightCharts.createChart(container, {
        width: container.clientWidth,
        height: container.clientHeight,
        layout: {
          background: { type: 'solid', color: 'transparent' },
          textColor: '#888',
        },
        grid: {
          vertLines: { color: 'rgba(0,255,65,0.05)' },
          horzLines: { color: 'rgba(0,255,65,0.05)' },
        },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        localization: {
          priceFormatter: (price) => {
            if (price >= 1000000) return '$' + (price / 1000000).toFixed(1) + 'M';
            if (price >= 1000) return '$' + (price / 1000).toFixed(0) + 'k';
            if (price >= 1) return '$' + price.toFixed(2);
            if (price >= 0.0001) return '$' + price.toFixed(6);
            return '$' + price.toExponential(2);
          },
        },
        rightPriceScale: { 
          borderColor: 'rgba(255,255,255,0.1)',
          scaleMargins: { top: 0.1, bottom: 0.1 }
        },
        timeScale: { 
          borderColor: 'rgba(255,255,255,0.1)', 
          timeVisible: true,
          rightOffset: 12,
          barSpacing: 6,
          minBarSpacing: 3,
          fixLeftEdge: false,
          fixRightEdge: false
        },
        handleScroll: {
          mouseWheel: true,
          pressedMouseMove: true,
          horzTouchDrag: true,
          vertTouchDrag: true
        },
        handleScale: {
          axisPressedMouseMove: true,
          mouseWheel: true,
          pinch: true
        }
      });
      
      S.candleSeries = S.chart.addCandlestickSeries({
        upColor: '#00ff88',
        downColor: '#ff4757',
        borderUpColor: '#00ff88',
        borderDownColor: '#ff4757',
        wickUpColor: '#00ff88',
        wickDownColor: '#ff4757',
      });
      
      S.lineSeries = S.chart.addLineSeries({
        color: '#00ffff',
        lineWidth: 2,
      });
      S.lineSeries.applyOptions({ visible: false });
      
      window.addEventListener('resize', () => {
        S.chart.applyOptions({ width: container.clientWidth });
      });
    }

    async function updateChart() {
      if (!S.selected || !S.candleSeries) return;
      
      console.log('[Chart] Updating for', S.selected.symbol, 'timeframe:', S.timeframe);
      
      try {
        // Fetch real chart data from RadFi API
        const data = await fetchRealChartData(S.selected, S.timeframe);
        
        if (data && data.length > 0) {
          console.log('[Chart] Loaded', data.length, 'real candles');
          S.candleSeries.setData(data);
          
          const lineData = data.map(d => ({ time: d.time, value: d.close }));
          S.lineSeries.setData(lineData);
          
          // Get price range for Y-axis scaling
          const prices = data.map(d => [d.high, d.low]).flat();
          const minPrice = Math.min(...prices);
          const maxPrice = Math.max(...prices);
          const priceRange = maxPrice - minPrice;
          
          console.log('[Chart] Price range: $' + fmtCompact(minPrice), 'to $' + fmtCompact(maxPrice));
          
          // Set Y-axis to visible range with 20% margin
          S.chart.priceScale('right').applyOptions({
            autoScale: true,
            scaleMargins: {
              top: 0.2,    // 20% margin on top
              bottom: 0.2  // 20% margin on bottom
            }
          });
          
          // Auto-fit time scale
          S.chart.timeScale().fitContent();
          
          // Apply custom price formatter
          S.candleSeries.applyOptions({
            priceFormat: {
              type: 'custom',
              formatter: (price) => {
                if (price >= 1000000) return '$' + (price / 1000000).toFixed(1) + 'M';
                if (price >= 1000) return '$' + (price / 1000).toFixed(0) + 'k';
                if (price >= 1) return '$' + price.toFixed(2);
                if (price >= 0.0001) return '$' + price.toFixed(6);
                return '$' + price.toExponential(2);
              }
            }
          });
          
        } else {
          console.log('[Chart] No real data, using fallback');
          // Fallback to generated data if no real data available
          const mcap = S.selected.marketCap || 1000000;
          const fallbackData = generateCandleData(mcap, S.timeframe);
          S.candleSeries.setData(fallbackData);
          
          const lineData = fallbackData.map(d => ({ time: d.time, value: d.close }));
          S.lineSeries.setData(lineData);
          
          S.chart.timeScale().fitContent();
        }
      } catch (error) {
        console.error('[Chart] Error fetching data:', error);
        // Fallback to generated data on error
        const mcap = S.selected.marketCap || 1000000;
        const fallbackData = generateCandleData(mcap, S.timeframe);
        S.candleSeries.setData(fallbackData);
        
        const lineData = fallbackData.map(d => ({ time: d.time, value: d.close }));
        S.lineSeries.setData(lineData);
        
        S.chart.timeScale().fitContent();
      }
    }
    
    // Fetch REAL chart data from RadFi histories API
    // Chart displays MARKET CAP on Y-axis (scaled by price movement)
async function fetchRealChartData(token, timeframeMinutes) {
  if (!token || !token.poolId) {
    console.log('[Chart] Token has no poolId:', token?.symbol);
    return null;
  }
  
  console.log('[Chart] Fetching real data for', token.symbol, 'pool:', token.poolId);
  
  try {
    // Fetch pool info to get decimals
    const poolRes = await fetch(`/api/pools`);
    const poolData = await poolRes.json();
    const pool = poolData.data.find(p => p._id === token.poolId);
    
    if (!pool) {
      console.log('[Chart] Pool not found:', token.poolId);
      return null;
    }
    
    const token0Decimal = pool.token0Decimal || 8; // BTC
    const token1Decimal = token.decimals || pool.token1Decimal || 18; // Rune
    
    console.log('[Chart] Pool decimals - BTC:', token0Decimal, 'Rune:', token1Decimal);
    
    // Fetch ALL swap histories - fetch multiple pages to get months of data
    let allSwaps = [];
    let page = 1;
    const pageSize = 1000;
    let hasMore = true;
    
    // Fetch up to 5 pages (5000 swaps) to get historical data
    while (hasMore && page <= 5) {
      const response = await fetch(`/api/histories?poolId=${token.poolId}&type=swap&pageSize=${pageSize}&page=${page}&sort=btcBlockTime`);
      const data = await response.json();
      
      if (!data.data || data.data.length === 0) {
        hasMore = false;
        break;
      }
      
      allSwaps = allSwaps.concat(data.data);
      
      // Stop if we got fewer results than page size (last page)
      if (data.data.length < pageSize) {
        hasMore = false;
      }
      
      page++;
    }
    
    if (allSwaps.length === 0) {
      console.log('[Chart] No swap history found');
      return null;
    }
    
    // Sort by time ascending (oldest first)
    allSwaps.sort((a, b) => a.btcBlockTime - b.btcBlockTime);
    
    console.log('[Chart] Fetched', allSwaps.length, 'swaps spanning', 
      new Date(allSwaps[0].btcBlockTime * 1000).toLocaleDateString(), 
      'to',
      new Date(allSwaps[allSwaps.length - 1].btcBlockTime * 1000).toLocaleDateString());
    
    // Get current market cap from token data
    const currentMarketCap = token.marketCap || 337000; // Fallback to $337k
    console.log('[Chart] Current market cap: $' + fmtCompact(currentMarketCap));
    
    // Calculate price RATIOS from each swap (just the relative price, no USD yet)
    const ratios = [];
    
    for (const swap of allSwaps) {
      // CRITICAL: Skip swaps without valid timestamp
      if (!swap.btcBlockTime || swap.btcBlockTime <= 0) {
        console.warn('[Chart] Skipping swap without valid btcBlockTime:', swap._id);
        continue;
      }
      
      const amount0 = parseFloat(swap.token0Amount); // BTC in smallest unit
      const amount1 = parseFloat(swap.token1Amount); // Rune in smallest unit
      
      if (!amount0 || !amount1 || amount0 <= 0 || amount1 <= 0) continue;
      
      // Adjust for decimals to get actual amounts
      const btcAmount = amount0 / Math.pow(10, token0Decimal);
      const runeAmount = amount1 / Math.pow(10, token1Decimal);
      
      // Calculate price ratio: BTC per Rune (just the ratio, no USD conversion)
      const priceRatio = btcAmount / runeAmount;
      
      // Sanity check on ratio (avoid extreme outliers)
      if (priceRatio > 0 && priceRatio < 1e10 && !isNaN(priceRatio) && isFinite(priceRatio)) {
        ratios.push({
          time: swap.btcBlockTime,
          ratio: priceRatio
        });
      }
    }
    
    if (ratios.length === 0) {
      console.log('[Chart] No valid price ratios calculated');
      return null;
    }
    
    // Use MEDIAN price ratio instead of latest (more stable, avoids outliers)
    const sortedRatios = [...ratios].sort((a, b) => a.ratio - b.ratio);
    const medianRatio = sortedRatios[Math.floor(sortedRatios.length / 2)].ratio;
    console.log('[Chart] Median price ratio:', medianRatio, '(from', ratios.length, 'swaps)');
    
    // Scale all ratios so that median ratio = current market cap
    // This makes the chart Y-axis show market cap values that change with price
    const pricesWithTime = [];
    
    for (const { time, ratio } of ratios) {
      const scaledPrice = (ratio / medianRatio) * currentMarketCap;
      
      // Additional sanity check on scaled price
      if (scaledPrice > 0 && scaledPrice < currentMarketCap * 100 && isFinite(scaledPrice)) {
        pricesWithTime.push({ time, price: scaledPrice });
      }
    }
    
    console.log('[Chart] Calculated', pricesWithTime.length, 'market cap values (filtered from', ratios.length, 'ratios)');
    
    if (pricesWithTime.length === 0) {
      console.error('[Chart] No valid scaled prices after filtering!');
      return null;
    }
    
    const minMcap = Math.min(...pricesWithTime.map(p => p.price));
    const maxMcap = Math.max(...pricesWithTime.map(p => p.price));
    console.log('[Chart] Market cap range: $' + fmtCompact(minMcap), 'to $' + fmtCompact(maxMcap));
    
    // Group by time interval to create candles
    const intervalSeconds = timeframeMinutes * 60;
    const candleMap = {};
    
    console.log('[Chart] Bucketing into', timeframeMinutes, 'minute candles (', intervalSeconds, 'seconds per bucket)');
    console.log('[Chart] Sample times:', pricesWithTime.slice(0, 5).map(p => new Date(p.time * 1000).toLocaleString()));
    
    for (const { time, price } of pricesWithTime) {
      const bucketTime = Math.floor(time / intervalSeconds) * intervalSeconds;
      
      if (!candleMap[bucketTime]) {
        candleMap[bucketTime] = {
          time: bucketTime,
          open: price,
          high: price,
          low: price,
          close: price,
          count: 1
        };
      } else {
        const candle = candleMap[bucketTime];
        candle.high = Math.max(candle.high, price);
        candle.low = Math.min(candle.low, price);
        candle.close = price;
        candle.count++;
      }
    }
    
    // Convert to array and sort
    const candles = Object.values(candleMap)
      .sort((a, b) => a.time - b.time);
    
    console.log('[Chart] Generated', candles.length, 'raw candles from', Object.keys(candleMap).length, 'buckets');
    console.log('[Chart] Time range:', 
      new Date(candles[0].time * 1000).toLocaleString(), 
      'to', 
      new Date(candles[candles.length - 1].time * 1000).toLocaleString());
    
    // Fill gaps between candles (max 50 intervals for larger timeframes)
    const maxGapFill = timeframeMinutes >= 60 ? 50 : 20;
    const filledCandles = [];
    
    for (let i = 0; i < candles.length; i++) {
      if (i > 0) {
        const prevTime = candles[i - 1].time;
        const currTime = candles[i].time;
        const gap = (currTime - prevTime) / intervalSeconds - 1;
        
        if (gap > 0 && gap <= maxGapFill) {
          const prevClose = candles[i - 1].close;
          for (let j = 1; j <= gap; j++) {
            filledCandles.push({
              time: prevTime + (j * intervalSeconds),
              open: prevClose,
              high: prevClose,
              low: prevClose,
              close: prevClose
            });
          }
        }
      }
      filledCandles.push(candles[i]);
    }
    
    console.log('[Chart] Final:', filledCandles.length, 'candles (after gap filling)');
    return filledCandles;
    
  } catch (error) {
    console.error('[Chart] Error:', error);
    return null;
  }
}

    function generateCandleData(currentMcap, timeframeMinutes) {
      const now = Math.floor(Date.now() / 1000);
      const data = [];
      const candleSeconds = timeframeMinutes * 60;
      
      // Calculate candles to show based on timeframe
      let totalCandles;
      if (timeframeMinutes <= 5) totalCandles = 300; // 25 hours for 1m/5m
      else if (timeframeMinutes === 15) totalCandles = 672; // 1 week
      else if (timeframeMinutes === 60) totalCandles = 720; // 1 month  
      else if (timeframeMinutes === 240) totalCandles = 540; // 3 months
      else totalCandles = 365; // 1 year for 1D
      
      // Scale volatility to timeframe - smaller timeframes = smaller candles
      const volatilityScale = Math.sqrt(timeframeMinutes / 15); // 15m baseline
      
      // Generate candles with random walk that stays near current price
      let price = currentMcap;
      
      for (let i = totalCandles; i >= 0; i--) {
        const time = now - i * candleSeconds;
        
        // Random walk with mean reversion to current price
        const distanceFromCurrent = (price - currentMcap) / currentMcap;
        const meanReversion = -distanceFromCurrent * 0.05; // Pull back toward current
        
        // Random drift
        const drift = (Math.random() - 0.5) * 0.002 * volatilityScale;
        
        // Apply movement
        price = price * (1 + drift + meanReversion);
        
        // Now create candle with variance
        const candleType = Math.random();
        let bodyPct, wickPct;
        
        if (candleType < 0.15) {
          // Big movers 15%
          bodyPct = (0.01 + Math.random() * 0.02) * volatilityScale;
          wickPct = 1.5 + Math.random();
        } else if (candleType < 0.40) {
          // Medium 25%
          bodyPct = (0.003 + Math.random() * 0.007) * volatilityScale;
          wickPct = 0.8 + Math.random() * 0.7;
        } else if (candleType < 0.70) {
          // Small 30%
          bodyPct = (0.001 + Math.random() * 0.002) * volatilityScale;
          wickPct = 0.3 + Math.random() * 0.5;
        } else {
          // Doji/tiny 30%
          bodyPct = (0.0002 + Math.random() * 0.0008) * volatilityScale;
          wickPct = 0.1 + Math.random() * 0.2;
        }
        
        const direction = Math.random() > 0.5 ? 1 : -1;
        const bodyMove = price * bodyPct * direction;
        
        const open = price;
        const close = price + bodyMove;
        
        const bodySize = Math.abs(bodyMove);
        const wickSize = bodySize * wickPct;
        
        const high = Math.max(open, close) + (Math.random() * wickSize);
        const low = Math.min(open, close) - (Math.random() * wickSize);
        
        data.push({ time, open, high, low, close });
        
        // Update price for next candle
        price = close;
      }
      
      // Force last candle to close at current mcap
      const lastCandle = data[data.length - 1];
      const prevClose = data[data.length - 2]?.close || currentMcap;
      
      lastCandle.open = prevClose;
      lastCandle.close = currentMcap;
      lastCandle.high = Math.max(prevClose, currentMcap) * 1.005;
      lastCandle.low = Math.min(prevClose, currentMcap) * 0.995;
      
      return data;
    }
    
    // Mute/Unmute video
    function toggleMute() {
      const video = document.getElementById('bgVideo');
      const btn = document.getElementById('muteBtn');
      
      if (video.muted) {
        video.muted = false;
        video.volume = 0.3; // Set to 30% volume
        btn.textContent = '';
        // Ensure video is playing
        video.play().catch(e => console.log('[Video] Play error:', e));
      } else {
        video.muted = true;
        btn.textContent = '';
      }
    }

    function setChartType(type) {
      S.chartType = type;
      document.querySelectorAll('.chart-type-btn').forEach(b => b.classList.remove('active'));
      event.target.classList.add('active');
      
      if (type === 'Line') {
        S.candleSeries.applyOptions({ visible: false });
        S.lineSeries.applyOptions({ visible: true });
      } else {
        S.candleSeries.applyOptions({ visible: true });
        S.lineSeries.applyOptions({ visible: false });
      }
    }

    // TRADE
    function handleTrade() {
      if (!S.userAddress) {
        connectWallet();
        return;
      }
      // Execute trade logic here
      toast('Trade execution coming soon!', 'info');
    }
    
    function setTradeMode(mode) {
      S.mode = mode;
      document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`.panel-tab.${mode}`).classList.add('active');
      
      const btn = document.getElementById('tradeBtn');
      btn.className = `trade-btn ${mode}`;
      btn.textContent = S.userAddress ? (mode === 'buy' ? 'Buy' : 'Sell') : 'Connect Wallet';
    }

    function setAmt(amt) {
      document.getElementById('fromAmt').value = amt;
      calcQuote();
    }

    function calcQuote() {
      const amt = parseFloat(document.getElementById('fromAmt').value) || 0;
      if (!amt || !S.to) {
        document.getElementById('toAmt').value = '';
        return;
      }
      const sats = amt * 100000000;
      const fee = sats * 0.01;
      const net = sats - fee;
      const out = S.to.priceInSats > 0 ? net / S.to.priceInSats : 0;
      
      document.getElementById('toAmt').value = out.toFixed(4);
      
      const name = S.to.displayTicker || S.to.symbol || '?';
      document.getElementById('rate').textContent = `1 BTC = ${fmtCompact(100000000 / (S.to.priceInSats || 1))} ${name}`;
      document.getElementById('fee').textContent = `${(fee / 100000000).toFixed(6)} BTC`;
      document.getElementById('impact').textContent = `~${(amt * 0.2).toFixed(2)}%`;
    }

    function flipTokens() {
      const tmp = S.from;
      S.from = S.to;
      S.to = tmp;
      updateToDisplay();
      calcQuote();
    }

    // TOKEN MODAL
    function openTokenModal(target) {
      S.selectTarget = target;
      const list = document.getElementById('tokenModalList');
      const btc = `<div class="wallet-option" onclick="pickToken({symbol:'BTC',tokenId:'0:0',priceInSats:100000000,displayTicker:'BTC'})">
        <div style="width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,#f7931a,#ff6600);display:flex;align-items:center;justify-content:center;font-size:1.5rem"></div>
        <div><div class="name">BTC</div><div class="desc">Bitcoin</div></div>
      </div>`;
      const opts = S.tokens.slice(0, 50).map(t => `
        <div class="wallet-option" onclick='pickToken(${JSON.stringify(t).replace(/'/g, "\\'")})'>
          <div style="width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--miami-orange),var(--miami-pink));display:flex;align-items:center;justify-content:center;font-size:1.5rem">${t.symbol || '?'}</div>
          <div><div class="name">${t.displayTicker || t.symbol}</div><div class="desc">${t.spacedRune || ''}</div></div>
        </div>
      `).join('');
      list.innerHTML = btc + opts;
      document.getElementById('tokenModal').classList.add('active');
    }

    function pickToken(t) {
      if (S.selectTarget === 'from') {
        S.from = t;
      } else {
        S.to = t;
        updateToDisplay();
        selectToken(t);
      }
      document.getElementById('tokenModal').classList.remove('active');
      calcQuote();
    }

    function filterModal(q) {
      q = q.toLowerCase();
      document.querySelectorAll('#tokenModalList .wallet-option').forEach(el => {
        el.style.display = el.textContent.toLowerCase().includes(q) ? 'flex' : 'none';
      });
    }

    // WALLET - RadFi Trading Wallet Flow
    function connectWallet() {
      document.getElementById('walletModal').classList.add('active');
    }

    async function doConnect(type) {
      document.getElementById('walletModal').classList.remove('active');
      
      try {
        toast('Connecting wallet...', 'info');
        
        let userAddress = null;
        let publicKey = null;
        
        // Step 1: Connect to user's wallet and get public key
        if (type === 'unisat' && window.unisat) {
          userAddress = (await window.unisat.requestAccounts())[0];
          publicKey = await window.unisat.getPublicKey();
        } else if (type === 'xverse' && window.XverseProviders) {
          const res = await window.XverseProviders.BitcoinProvider.request('getAccounts', {
            purposes: ['payment', 'ordinals']
          });
          if (res.result && res.result.length > 0) {
            const account = res.result.find(a => a.purpose === 'payment') || res.result[0];
            userAddress = account.address;
            publicKey = account.publicKey;
          }
        } else if (type === 'okx' && window.okxwallet) {
          const conn = await window.okxwallet.bitcoin.connect();
          userAddress = conn.address;
          publicKey = conn.publicKey;
        } else {
          toast(`${type} wallet not installed`, 'error');
          return;
        }
        
        if (!userAddress || !publicKey) {
          toast('Failed to get wallet details', 'error');
          return;
        }
        
        S.userAddress = userAddress;
        S.publicKey = publicKey;
        S.walletType = type;
        
        console.log(`[Auth] Connected wallet: ${userAddress}`);
        
        // Step 2: Sign message for BIP322 authentication
        toast('Signing authentication message...', 'info');
        
        const message = Date.now().toString();
        let signature = null;
        
        if (type === 'unisat') {
          signature = await window.unisat.signMessage(message);
        } else if (type === 'xverse') {
          const signRes = await window.XverseProviders.BitcoinProvider.request('signMessage', {
            address: userAddress,
            message: message
          });
          signature = signRes.result.signature;
        } else if (type === 'okx') {
          signature = await window.okxwallet.bitcoin.signMessage(message, 'bip322-simple');
        }
        
        if (!signature) {
          toast('Failed to sign message', 'error');
          return;
        }
        
        // Step 3: Authenticate with RadFi API (this returns your original trading wallet!)
        toast('Authenticating with RadFi...', 'info');
        
        const authResponse = await fetch('/api/auth/authenticate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message,
            signature,
            address: userAddress,
            publicKey
          })
        });
        
        const authData = await authResponse.json();
        
        if (authData.code !== '1' || !authData.data) {
          toast('Authentication failed: ' + (authData.message || 'Unknown error'), 'error');
          return;
        }
        
        // Step 4: RadFi auth response contains the tradingAddress (your original wallet!)
        S.accessToken = authData.data.accessToken;
        S.refreshToken = authData.data.refreshToken;
        S.tradingAddress = authData.data.tradingAddress; // This is the source of truth!
        S.walletData = authData.data.wallet;
        
        const isExistingWallet = authData.data.wallet && authData.data.wallet.createdAt < (Date.now() - 60000);
        
        console.log(`[Auth] Authenticated! Trading wallet: ${S.tradingAddress}`);
        console.log(`[Auth] Wallet created:`, new Date(authData.data.wallet?.createdAt).toLocaleString());
        
        // Save to localStorage
        localStorage.setItem('radfi_auth', JSON.stringify({
          userAddress,
          tradingAddress: S.tradingAddress,
          publicKey,
          walletType: type,
          accessToken: S.accessToken,
          refreshToken: S.refreshToken,
          walletData: S.walletData
        }));
        
        // Update UI
        document.getElementById('connectBtn').textContent = userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
        document.getElementById('connectBtn').classList.add('connected');
        document.getElementById('tradeBtn').disabled = false;
        document.getElementById('tradeBtn').textContent = S.mode === 'buy' ? 'Buy' : 'Sell';
        
        // Show balance display
        document.getElementById('balanceDisplay').style.display = 'flex';
        
        if (isExistingWallet) {
          toast(` Synced your RadFi wallet: ${S.tradingAddress.slice(0, 10)}...`, 'success');
        } else {
          toast(` Trading wallet created: ${S.tradingAddress.slice(0, 10)}...`, 'success');
        }
        
        // Step 6: Fetch and display wallet balance
        await fetchTradingWalletBalance();
        
        // Step 7: Sync existing RadFi positions (if any)
        setTimeout(() => syncExistingPositions(), 2000);
        
      } catch (e) {
        console.error('Wallet connection error:', e);
        toast('Connection failed: ' + e.message, 'error');
      }
    }
    
    // Fetch trading wallet balance and details
    async function fetchTradingWalletBalance() {
      if (!S.tradingAddress) return;
      
      try {
        // Fetch wallet details from RadFi API
        const response = await fetch(`/api/wallets/details/${S.tradingAddress}`, {
          headers: S.accessToken ? { 'Authorization': `Bearer ${S.accessToken}` } : {}
        });
        
        const data = await response.json();
        
        if (data.success && data.data) {
          const wallet = data.data;
          S.tradingWalletBalance = wallet.balance || 0;
          S.walletData = wallet;
          
          // Check wallet history to see if it's been used before
          await checkWalletHistory();
          
          // Display balance in UI
          displayWalletInfo(wallet);
          
          // Show balance toast
          const balanceBTC = (wallet.balance || 0) / 1e8;
          if (balanceBTC > 0) {
            toast(` Trading wallet balance: ${balanceBTC.toFixed(8)} BTC`, 'success');
          } else if (S.hasWalletHistory) {
            toast(` Synced existing RadFi wallet (previously used)`, 'info');
          } else {
            toast(` New trading wallet created. Fund it to start trading.`, 'info');
          }
          
          return wallet;
        }
      } catch (error) {
        console.error('Failed to fetch trading wallet balance:', error);
      }
    }
    
    // Check if wallet has previous transaction history
    async function checkWalletHistory() {
      if (!S.tradingAddress) return;
      
      try {
        // Check for any previous transactions
        const historyResponse = await fetch(`/api/histories?userAddress=${S.tradingAddress}&pageSize=1`);
        const historyData = await historyResponse.json();
        
        if (historyData.success && historyData.data && historyData.data.length > 0) {
          S.hasWalletHistory = true;
          
          // Get wallet creation date from wallet data
          const createdDate = S.walletData?.createdAt ? new Date(S.walletData.createdAt) : null;
          const firstTxDate = new Date(historyData.data[0].createdAt);
          
          console.log('Existing RadFi wallet detected:');
          console.log('  Created:', createdDate?.toLocaleDateString() || 'Unknown');
          console.log('  First transaction:', firstTxDate.toLocaleDateString());
          console.log('  Total transactions: Checking...');
          
          // Check positions (LP/Market Maker)
          const positionsResponse = await fetch(`/api/positions?userAddress=${S.tradingAddress}&pageSize=1`);
          const positionsData = await positionsResponse.json();
          
          if (positionsData.success && positionsData.data && positionsData.data.length > 0) {
            console.log('  Has LP positions: Yes');
          }
        } else {
          S.hasWalletHistory = false;
          console.log('New trading wallet (no previous activity)');
        }
      } catch (error) {
        console.error('Failed to check wallet history:', error);
        S.hasWalletHistory = false;
      }
    }
    
    // Display wallet info in header
    function displayWalletInfo(wallet) {
      const connectBtn = document.getElementById('connectBtn');
      const balanceBTC = ((wallet.balance || 0) / 1e8).toFixed(4);
      
      // Update button to show balance
      connectBtn.title = `Trading Wallet: ${S.tradingAddress}\nBalance: ${balanceBTC} BTC\nClick to view details`;
      connectBtn.style.cursor = 'pointer';
      
      // Make button clickable to show wallet details
      connectBtn.onclick = showWalletDetails;
      
      // Add balance indicator to header if not exists
      let balanceIndicator = document.getElementById('walletBalance');
      if (!balanceIndicator) {
        balanceIndicator = document.createElement('span');
        balanceIndicator.id = 'walletBalance';
        balanceIndicator.style.cssText = 'margin-left: 0.5rem; padding: 0.25rem 0.75rem; background: rgba(0,255,136,0.1); border: 1px solid var(--green); border-radius: 12px; font-family: "JetBrains Mono", monospace; font-size: 0.85rem; color: var(--green); cursor: pointer;';
        balanceIndicator.onclick = () => fetchTradingWalletBalance();
        balanceIndicator.title = 'Click to refresh balance';
        connectBtn.parentNode.insertBefore(balanceIndicator, connectBtn.nextSibling);
      }
      
      balanceIndicator.textContent = `${balanceBTC} BTC`;
    }
    
    // Show wallet details modal
    function showWalletDetails() {
      if (!S.tradingAddress) {
        connectWallet();
        return;
      }
      
      const balanceBTC = (S.tradingWalletBalance / 1e8).toFixed(8);
      const created = S.walletData?.createdAt ? new Date(S.walletData.createdAt).toLocaleDateString() : 'Unknown';
      
      const details = `

RadFi Trading Wallet Details


User Wallet (${S.walletType}):
${S.userAddress}

Trading Wallet (2-of-2 multisig):
${S.tradingAddress}

Balance: ${balanceBTC} BTC
Created: ${created}
Status: ${S.hasWalletHistory ? 'Previously used on RadFi' : 'New wallet'}



View on RadFi:
https://app.radfi.co

To fund your trading wallet:
1. Go to app.radfi.co
2. Connect with ${S.walletType}
3. Transfer from your main wallet
      `.trim();
      
      alert(details);
    }
    
    // Sync existing RadFi positions (if any)
    async function syncExistingPositions() {
      if (!S.tradingAddress || !S.accessToken) return;
      
      try {
        console.log('Checking for existing RadFi positions...');
        
        // Fetch user's LP positions from RadFi
        const positionsResponse = await fetch(`/api/positions?userAddress=${S.tradingAddress}&pageSize=50`, {
          headers: { 'Authorization': `Bearer ${S.accessToken}` }
        });
        
        const positionsData = await positionsResponse.json();
        
        if (positionsData.success && positionsData.data && positionsData.data.length > 0) {
          console.log(`Found ${positionsData.data.length} existing LP positions`);
          
          // Convert RadFi positions to our MM format
          for (const pos of positionsData.data) {
            // Check if we already have this position
            const exists = mmState.positions.find(p => p.nftId === pos.nftId);
            if (exists) continue;
            
            // Get token info
            const token = S.tokens.find(t => t.tokenId === pos.token1Id || t.tokenId === pos.token0Id);
            if (!token) continue;
            
            // Calculate deposited BTC amount
            const btcAmount = pos.token0Id === '0:0' ? parseFloat(pos.amount0) / 1e8 : parseFloat(pos.amount1) / 1e8;
            
            // Add to our MM positions
            const mmPosition = {
              id: 'radfi-' + pos.nftId,
              nftId: pos.nftId,
              token: token,
              pool: { _id: pos.poolId, token0Id: pos.token0Id, token1Id: pos.token1Id },
              strategy: 'radfi-lp',
              depositedBTC: btcAmount,
              startTime: new Date(pos.createdAt).getTime(),
              entryPrice: 0, // Will be calculated
              feesEarned: 0,  // Will be calculated
              ilLoss: 0,
              status: 'active',
              syncedFromRadFi: true
            };
            
            mmState.positions.push(mmPosition);
          }
          
          if (positionsData.data.length > 0) {
            saveMMLoc();
            renderMMPositions();
            toast(` Synced ${positionsData.data.length} existing position(s) from RadFi`, 'success');
          }
        }
      } catch (error) {
        console.error('Failed to sync existing positions:', error);
      }
    }
    
    // Restore session from localStorage
    function restoreSession() {
      const stored = localStorage.getItem('radfi_auth');
      if (stored) {
        try {
          const auth = JSON.parse(stored);
          S.userAddress = auth.userAddress;
          S.tradingAddress = auth.tradingAddress;
          S.publicKey = auth.publicKey;
          S.walletType = auth.walletType;
          S.accessToken = auth.accessToken;
          S.refreshToken = auth.refreshToken;
          S.walletData = auth.walletData;
          
          // Update UI
          document.getElementById('connectBtn').textContent = auth.userAddress.slice(0, 6) + '...' + auth.userAddress.slice(-4);
          document.getElementById('connectBtn').classList.add('connected');
          document.getElementById('tradeBtn').disabled = false;
          document.getElementById('tradeBtn').textContent = S.mode === 'buy' ? 'Buy' : 'Sell';
          
          console.log('Session restored. Trading wallet:', S.tradingAddress);
          
          // Fetch balance for restored session
          fetchTradingWalletBalance();
          
          // Sync existing positions after tokens load
          setTimeout(() => {
            if (S.tokens.length > 0) syncExistingPositions();
          }, 3000);
        } catch (e) {
          console.error('Failed to restore session:', e);
          localStorage.removeItem('radfi_auth');
        }
      }
    }

    // ========== PROFILE PAGE ==========
    
    async function loadProfilePage() {
      if (!S.userAddress) {
        toast('Please connect your wallet first');
        return;
      }
      
      // Update wallet addresses
      document.getElementById('profileConnectedWallet').textContent = 
        S.userAddress.slice(0, 8) + '...' + S.userAddress.slice(-6);
      
      if (S.tradingAddress) {
        document.getElementById('profileTradingWallet').textContent = 
          S.tradingAddress.slice(0, 8) + '...' + S.tradingAddress.slice(-6);
        document.getElementById('receiveAddress').textContent = S.tradingAddress;
        document.getElementById('createTradingWalletSection').style.display = 'none';
      } else {
        document.getElementById('profileTradingWallet').textContent = 'Not created';
        document.getElementById('receiveAddress').textContent = '--';
        document.getElementById('createTradingWalletSection').style.display = 'block';
      }
      
      // Load balances
      await loadWalletBalances();
      
      // Load holdings
      await loadTokenHoldings();
      
      // Load MM positions
      await loadProfileMMPositions();
    }
    
    async function loadWalletBalances() {
      try {
        // Load BTC wallet balance via mempool.space API
        if (S.userAddress) {
          const res = await fetch(`https://mempool.space/api/address/${S.userAddress}`);
          const data = await res.json();
          const btcBalance = (data.chain_stats.funded_txo_sum - data.chain_stats.spent_txo_sum) / 100000000;
          document.getElementById('profileBTCBalance').textContent = btcBalance.toFixed(8) + ' BTC';
        }
        
        // Load RadFi trading wallet balance
        if (S.tradingAddress) {
          const res = await fetch(`https://mempool.space/api/address/${S.tradingAddress}`);
          const data = await res.json();
          const tradingBalance = (data.chain_stats.funded_txo_sum - data.chain_stats.spent_txo_sum) / 100000000;
          document.getElementById('profileTradingBalance').textContent = tradingBalance.toFixed(8) + ' BTC';
        }
      } catch (e) {
        console.error('Failed to load wallet balances:', e);
        toast('Failed to load balances');
      }
    }
    
    async function loadTokenHoldings() {
      const container = document.getElementById('tokenHoldingsList');
      
      if (!S.tradingAddress) {
        container.innerHTML = '<p class="holdings-empty">Create a trading wallet to see token holdings</p>';
        return;
      }
      
      try {
        // Fetch LP positions to determine which tokens user has
        const res = await fetch(`${API}/api/positions?tradingAddress=${S.tradingAddress}`);
        const result = await res.json();
        
        if (!result.data || result.data.length === 0) {
          container.innerHTML = '<p class="holdings-empty">No token holdings found</p>';
          return;
        }
        
        // Get unique tokens from positions
        const tokenIds = new Set();
        result.data.forEach(pos => {
          if (pos.token0Id !== '0:0') tokenIds.add(pos.token0Id);
          if (pos.token1Id !== '0:0') tokenIds.add(pos.token1Id);
        });
        
        // Fetch token details
        const tokens = S.tokens.filter(t => tokenIds.has(t.tokenId));
        
        if (tokens.length === 0) {
          container.innerHTML = '<p class="holdings-empty">No token holdings found</p>';
          return;
        }
        
        // Render token holdings
        container.innerHTML = tokens.map(token => `
          <div class="holding-item">
            <div class="holding-info">
              <div class="holding-icon">${token.emoji || ''}</div>
              <div class="holding-details">
                <h3>${token.displayTicker || token.symbol}</h3>
                <p>${token.spacedRune || token.rune}</p>
              </div>
            </div>
            <div class="holding-balance">
              <span class="holding-amount">In LP</span>
              <span class="holding-usd">$${formatNum(token.marketCap)}</span>
            </div>
          </div>
        `).join('');
        
      } catch (e) {
        console.error('Failed to load token holdings:', e);
        container.innerHTML = '<p class="holdings-empty">Failed to load holdings</p>';
      }
    }
    
    async function loadProfileMMPositions() {
      const container = document.getElementById('mmPositionsList');
      
      // Load from localStorage
      const positions = loadMMLoc();
      
      if (positions.length === 0) {
        container.innerHTML = '<p class="holdings-empty">No market maker positions</p>';
        return;
      }
      
      // Render positions
      container.innerHTML = positions.map(pos => {
        const token = S.tokens.find(t => t.tokenId === pos.tokenId);
        const statusClass = pos.status === 'active' ? 'active' : 'pending';
        const pnlClass = pos.totalPnL >= 0 ? 'positive' : 'negative';
        
        return `
          <div class="mm-position-item">
            <div class="mm-position-header">
              <div class="mm-position-token">${token?.displayTicker || pos.symbol}</div>
              <div class="mm-position-status ${statusClass}">${pos.status.toUpperCase()}</div>
            </div>
            <div class="mm-position-stats">
              <div class="mm-position-stat">
                <span class="mm-position-stat-label">Deposited</span>
                <span class="mm-position-stat-value">${pos.deposited.toFixed(4)} BTC</span>
              </div>
              <div class="mm-position-stat">
                <span class="mm-position-stat-label">Current Value</span>
                <span class="mm-position-stat-value">${pos.value.toFixed(4)} BTC</span>
              </div>
              <div class="mm-position-stat">
                <span class="mm-position-stat-label">Fees Earned</span>
                <span class="mm-position-stat-value">${pos.fees.toFixed(4)} BTC</span>
              </div>
              <div class="mm-position-stat">
                <span class="mm-position-stat-label">Total P&L</span>
                <span class="mm-position-stat-value ${pnlClass}">${pos.totalPnL >= 0 ? '+' : ''}${pos.totalPnL.toFixed(4)} BTC</span>
              </div>
              <div class="mm-position-stat">
                <span class="mm-position-stat-label">APY</span>
                <span class="mm-position-stat-value">${pos.apy.toFixed(1)}%</span>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }
    
    async function createTradingWallet() {
      if (!S.userAddress || !S.publicKey) {
        toast('Please connect your wallet first');
        return;
      }
      
      try {
        const res = await fetch(`${API}/api/wallets`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            walletAddress: S.userAddress,
            publicKey: S.publicKey
          })
        });
        
        const result = await res.json();
        
        if (result.code === '1' && result.data.tradingAddress) {
          S.tradingAddress = result.data.tradingAddress;
          toast('Trading wallet created successfully!');
          await loadProfilePage();
        } else {
          toast('Failed to create trading wallet: ' + result.message);
        }
      } catch (e) {
        console.error('Failed to create trading wallet:', e);
        toast('Error creating trading wallet');
      }
    }
    
    function switchTransferTab(tab) {
      document.querySelectorAll('.transfer-tab').forEach(t => t.classList.remove('active'));
      event.target.classList.add('active');
      
      document.getElementById('receiveTab').style.display = tab === 'receive' ? 'block' : 'none';
      document.getElementById('sendTab').style.display = tab === 'send' ? 'block' : 'none';
    }
    
    function updateSendForm() {
      const assetType = document.getElementById('sendAssetType').value;
      document.getElementById('sendRuneSelector').style.display = assetType === 'rune' ? 'block' : 'none';
      
      if (assetType === 'rune') {
        // Populate rune tokens
        const select = document.getElementById('sendRuneToken');
        select.innerHTML = '<option value="">-- Choose Token --</option>' + 
          S.tokens.filter(t => t.hasPool).map(t => 
            `<option value="${t.tokenId}">${t.displayTicker || t.symbol}</option>`
          ).join('');
      }
    }
    
    async function sendFunds() {
      const assetType = document.getElementById('sendAssetType').value;
      const recipient = document.getElementById('sendRecipient').value.trim();
      const amount = parseFloat(document.getElementById('sendAmount').value);
      
      if (!recipient || !amount || amount <= 0) {
        toast('Please enter valid recipient and amount');
        return;
      }
      
      if (!S.tradingAddress || !S.accessToken) {
        toast('Please connect your trading wallet first');
        return;
      }
      
      try {
        let transactionType = 'withdraw';
        let transactionData = {
          tradingAddress: S.tradingAddress,
          toAddress: recipient,
          amount: Math.floor(amount * 100000000) // Convert to sats
        };
        
        if (assetType === 'rune') {
          const tokenId = document.getElementById('sendRuneToken').value;
          if (!tokenId) {
            toast('Please select a token');
            return;
          }
          transactionData.tokenId = tokenId;
        }
        
        // Create transaction via RadFi API
        const res = await fetch(`${API}/api/transactions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${S.accessToken}`
          },
          body: JSON.stringify({
            type: transactionType,
            ...transactionData
          })
        });
        
        const result = await res.json();
        
        if (result.code === '1') {
          toast('Transaction created! Please sign in your wallet');
          // Transaction signing would happen here via wallet provider
        } else {
          toast('Failed to create transaction: ' + result.message);
        }
      } catch (e) {
        console.error('Failed to send funds:', e);
        toast('Error sending funds');
      }
    }
    
    function copyAddress() {
      const address = S.tradingAddress;
      if (!address || address === '--') {
        toast('No address to copy');
        return;
      }
      
      navigator.clipboard.writeText(address).then(() => {
        toast('Address copied to clipboard!');
      }).catch(() => {
        toast('Failed to copy address');
      });
    }
    
    async function refreshHoldings() {
      await loadTokenHoldings();
      toast('Holdings refreshed');
    }
    
    async function refreshMMPositions() {
      await loadProfileMMPositions();
      toast('Positions refreshed');
    }

    // NAV
    function navigate(page) {
      document.querySelectorAll('.nav a').forEach(a => a.classList.remove('active'));
      document.querySelector(`.nav a[data-page="${page}"]`)?.classList.add('active');
      document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
      document.getElementById(`page-${page}`)?.classList.add('active');
      
      if (page === 'tokens') renderAllTokens();
      if (page === 'radpad') loadEtchedRunes();
      if (page === 'profile') loadProfilePage();
    }

    document.querySelectorAll('.nav a[data-page]').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault();
        navigate(a.dataset.page);
      });
    });

    // FILTER
    function filterTable(q) {
      q = q.toLowerCase();
      document.querySelectorAll('#tokenTbody tr').forEach(r => {
        r.style.display = r.textContent.toLowerCase().includes(q) ? '' : 'none';
      });
    }

    function filterAllTable(q) {
      q = q.toLowerCase();
      document.querySelectorAll('#allTokensTbody tr').forEach(r => {
        r.style.display = r.textContent.toLowerCase().includes(q) ? '' : 'none';
      });
    }

    // UTILS
    function fmtNum(n) {
      if (n < 0.00001) return n.toExponential(2);
      if (n < 1) return n.toFixed(6);
      return n.toLocaleString('en-US', { maximumFractionDigits: 4 });
    }

    function fmtSats(n) {
      if (n < 0.0001) return n.toExponential(2);
      if (n < 1) return n.toFixed(6);
      return n.toFixed(4);
    }

    function fmtCompact(n) {
      if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
      if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
      if (n >= 1e3) return (n / 1e3).toFixed(2) + 'K';
      return n.toFixed(2);
    }

    function toast(msg, type = 'info') {
      const t = document.getElementById('toast');
      document.getElementById('toastMsg').textContent = msg;
      t.className = `toast ${type} show`;
      setTimeout(() => t.classList.remove('show'), 3000);
    }

    // CLOSE MODALS
    document.querySelectorAll('.modal-overlay').forEach(m => {
      m.addEventListener('click', e => { if (e.target === m) m.classList.remove('active'); });
    });

    // TF BUTTONS
    document.querySelectorAll('.tf-btn').forEach(b => {
      b.addEventListener('click', () => {
        const tf = parseInt(b.getAttribute('data-tf'));
        S.timeframe = tf;
        document.querySelectorAll('.tf-btn').forEach(x => x.classList.remove('active'));
        b.classList.add('active');
        updateChart();
      });
    });

    // MARKET MAKER
    let mmState = {
      selectedToken: null,
      selectedStrategy: 'radfi-lp', // Default to RadFi LP strategy
      positions: []
    };

    async function populateMMTokens() {
  const select = document.getElementById('mmTokenSelect');
  if (!select) return;
  
  const validTokens = S.tokens.filter(t => t.poolId);
  
  if (validTokens.length === 0) {
    select.innerHTML = '<option>No pools available</option>';
    return;
  }
  
  select.innerHTML = '<option value="">-- Choose Token --</option>';
  
  validTokens.slice(0, 20).forEach(t => {
    const opt = document.createElement('option');
    opt.value = t.tokenId;
    opt.textContent = `${t.displayTicker || t.symbol} ($${fmtCompact(t.marketCap || 0)})`;
    opt.dataset.token = JSON.stringify(t);
    select.appendChild(opt);
  });

  select.onchange = async (e) => {
    if (!e.target.value) {
      document.getElementById('mmTokenInfo').style.display = 'none';
      mmState.selectedToken = null;
      return;
    }
    
    const token = JSON.parse(e.target.selectedOptions[0].dataset.token);
    mmState.selectedToken = token;
    
    console.log('[MM] Selected:', token.symbol, 'poolId:', token.poolId);
    
    // poolTVL is already in USD from our enriched token data!
    if (token.poolTVL) {
      document.getElementById('mmPoolTVL').textContent = '$' + fmtCompact(token.poolTVL);
      console.log('[MM] Pool TVL: $' + token.poolTVL.toFixed(0));
    } else {
      document.getElementById('mmPoolTVL').textContent = '$' + fmtCompact(token.marketCap || 0);
      console.log('[MM] No pool TVL, using market cap');
    }
    
    document.getElementById('mmTokenMcap').textContent = '$' + fmtCompact(token.marketCap || 0);
    document.getElementById('mmTokenVol').textContent = '$' + fmtCompact(token.volume24h || 0);
    document.getElementById('mmTokenInfo').style.display = 'block';
  };
}

    function setMMAmount(amt) {
      document.getElementById('mmDepositAmount').value = amt;
      updateMMUSD();
    }
    
    // Update USD display for MM deposit amount with REAL BTC price
    async function updateMMUSD() {
      const btcAmount = parseFloat(document.getElementById('mmDepositAmount').value) || 0;
      const usdAmount = (btcAmount * btcPriceUSD).toFixed(2);
      document.getElementById('mmDepositUSD').textContent = parseFloat(usdAmount).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    function selectMMStrategy(strategy) {
      mmState.selectedStrategy = strategy;
      document.querySelectorAll('.mm-strategy-option').forEach(o => o.classList.remove('active'));
      event.target.closest('.mm-strategy-option').classList.add('active');
      
      if (strategy === 'custom') {
        document.getElementById('mmStrategyParams').style.display = 'block';
      } else {
        document.getElementById('mmStrategyParams').style.display = 'none';
      }
    }

    async function depositToMM() {
      if (!S.userAddress) {
        connectWallet();
        return;
      }

      if (!mmState.selectedToken) {
        toast('Please select a token to market make', 'error');
        return;
      }

      if (!mmState.selectedStrategy) {
        toast('Please select a market making strategy', 'error');
        return;
      }

      const amount = parseFloat(document.getElementById('mmDepositAmount').value);
      if (!amount || amount < 0.001) {
        toast('Minimum deposit is 0.001 BTC', 'error');
        return;
      }

      try {
        toast('Finding pool...', 'info');

        // Find pool for this token
        const poolResponse = await fetch('/api/pools');
        const poolData = await poolResponse.json();
        const pool = poolData.data.find(p => 
          (p.token1Id === mmState.selectedToken.tokenId && p.token0Id === '0:0') ||
          (p.token0Id === mmState.selectedToken.tokenId && p.token1Id === '0:0')
        );

        if (!pool) {
          toast('No liquidity pool found for this token', 'error');
          return;
        }

        toast('Calculating position...', 'info');

        // Calculate token amounts based on pool ratio
        const btcReserve = parseFloat(pool.token0Reserve || pool.tvl);
        const tokenReserve = parseFloat(pool.token1Reserve || 1);
        const currentPrice = btcReserve / tokenReserve;
        const tokenAmount = Math.floor(amount / currentPrice);

        const amount0 = pool.token0Id === '0:0' ? Math.floor(amount * 1e8) : tokenAmount;
        const amount1 = pool.token1Id === '0:0' ? Math.floor(amount * 1e8) : tokenAmount;

        toast('Authentication required - Connect wallet to continue', 'info');

        // Note: Real deployment requires wallet connection and JWT auth
        // For now, store position in pending state
        const position = {
          id: 'mm-' + Date.now(),
          token: mmState.selectedToken,
          pool: pool,
          strategy: mmState.selectedStrategy,
          depositedBTC: amount,
          startTime: Date.now(),
          entryPrice: currentPrice,
          feesEarned: 0,
          ilLoss: 0,
          status: 'pending-auth',
          vmTxParams: {
            poolId: pool._id,
            userAddress: S.tradingAddress || S.userAddress, // Use trading wallet
            amount0,
            amount1,
            token0Id: pool.token0Id,
            token1Id: pool.token1Id,
            upperTick: pool.upperTick || '887200',
            lowerTick: pool.lowerTick || '-887200',
            feeRate: pool.fee,
            tickSpacing: pool.tickSpacing || 200,
            scVersion: pool.scVersion || 'v4'
          }
        };

        mmState.positions.push(position);
        saveMMLoc();
        renderMMPositions();
        toast('Position created! Connect wallet to activate', 'success');

      } catch (error) {
        console.error('MM deployment error:', error);
        toast('Failed to deploy market maker: ' + error.message, 'error');
      }
    }

    function renderMMPositions() {
      const container = document.getElementById('mmPositions');
      
      if (mmState.positions.length === 0) {
        container.innerHTML = `
          <div class="mm-empty-state">
            <span style="font-size:3rem"></span>
            <p>No active market making positions</p>
            <p class="mm-desc">Deploy capital above to get started</p>
          </div>
        `;
        return;
      }

      const html = `
        <table style="width:100%;font-size:0.9rem">
          <thead>
            <tr>
              <th>Token</th>
              <th>Deposited</th>
              <th>Value</th>
              <th>Fees Earned</th>
              <th>IL</th>
              <th>Total PnL</th>
              <th>APY</th>
              <th>Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            ${mmState.positions.map((p, i) => {
              const runningHours = (Date.now() - p.startTime) / (1000 * 60 * 60);
              const currentValue = p.depositedBTC + p.feesEarned + (p.ilLoss || 0);
              const totalPnL = currentValue - p.depositedBTC;
              const apy = runningHours > 0 ? (totalPnL / p.depositedBTC) * (8760 / runningHours) * 100 : 0;
              
              return `
              <tr>
                <td>${p.token.displayTicker || p.token.symbol}</td>
                <td class="mono">${p.depositedBTC.toFixed(4)} BTC</td>
                <td class="mono">${currentValue.toFixed(4)} BTC</td>
                <td class="mono green">+${p.feesEarned.toFixed(6)} BTC</td>
                <td class="mono ${(p.ilLoss || 0) < 0 ? 'red' : 'green'}">
                  ${((p.ilLoss || 0) * 100).toFixed(2)}%
                </td>
                <td class="mono ${totalPnL >= 0 ? 'green' : 'red'}">
                  ${totalPnL >= 0 ? '+' : ''}${totalPnL.toFixed(6)} BTC
                </td>
                <td class="mono ${apy >= 0 ? 'green' : 'red'}">
                  ${apy.toFixed(1)}%
                </td>
                <td>
                  <span style="display:inline-block;padding:0.25rem 0.5rem;border-radius:4px;font-size:0.75rem;
                    background:${p.status === 'active' ? 'rgba(0,255,136,0.2)' : 'rgba(255,215,0,0.2)'};
                    color:${p.status === 'active' ? 'var(--green)' : 'var(--yellow)'}">
                    ${p.status}
                  </span>
                </td>
                <td>
                  <button onclick="withdrawMM(${i})" 
                    style="padding:0.25rem 0.75rem;background:var(--miami-orange);border:none;
                    border-radius:6px;color:white;cursor:pointer;font-size:0.85rem">
                    Withdraw
                  </button>
                </td>
              </tr>
            `;
            }).join('')}
          </tbody>
        </table>
      `;
      container.innerHTML = html;
    }

    function saveMMLoc() {
      localStorage.setItem('mm_positions', JSON.stringify(mmState.positions));
    }

    function loadMMLoc() {
      const stored = localStorage.getItem('mm_positions');
      if (stored) {
        try {
          mmState.positions = JSON.parse(stored);
          renderMMPositions();
        } catch (e) {
          console.error('Failed to load MM positions:', e);
        }
      }
    }

    async function withdrawMM(index) {
      const position = mmState.positions[index];
      
      // Calculate fees breakdown
      const profitableFees = Math.max(0, position.feesEarned);
      const platformFee = profitableFees * 0.10;
      const userFees = profitableFees * 0.90;
      const totalReturn = position.depositedBTC + userFees + (position.ilLoss || 0);
      
      const message = `Withdraw from ${position.token.symbol} pool?\n\n` +
        `Principal: ${position.depositedBTC.toFixed(4)} BTC\n` +
        `Fees Earned: ${profitableFees.toFixed(6)} BTC\n` +
        `Your Share (90%): ${userFees.toFixed(6)} BTC\n` +
        `Platform Fee (10%): ${platformFee.toFixed(6)} BTC\n` +
        `IL: ${((position.ilLoss || 0) * 100).toFixed(2)}%\n` +
        `Total Return: ${totalReturn.toFixed(6)} BTC`;
      
      if (!confirm(message)) {
        return;
      }

      try {
        toast('Calculating withdrawal...', 'info');

        const withdrawPayload = {
          nftId: position.nftId || '1',
          userAddress: S.tradingAddress || S.userAddress, // Use trading wallet
          liquidityValue: Math.floor(position.depositedBTC * 1e8),
          amount0: '0',
          amount1: '0',
          token0Id: position.pool.token0Id,
          token1Id: position.pool.token1Id,
          scVersion: position.pool.scVersion || 'v4',
          feesEarned: position.feesEarned
        };

        // Note: Real withdrawal requires JWT auth
        toast(`Withdrawing: ${totalReturn.toFixed(6)} BTC total`, 'info');
        toast('Connect wallet to complete withdrawal', 'info');

        // Remove position
        mmState.positions.splice(index, 1);
        saveMMLoc();
        renderMMPositions();
        toast(`Withdrawal ready. You'll receive: ${userFees.toFixed(6)} BTC in fees (90%)`, 'success');

      } catch (error) {
        console.error('Withdrawal error:', error);
        toast('Failed to withdraw: ' + error.message, 'error');
      }
    }

    // Monitor and update positions every 5 minutes
    async function updateMMPositions() {
      for (let position of mmState.positions) {
        if (!position.pool) continue;

        try {
          // Fetch current pool stats
          const poolResponse = await fetch('/api/pools');
          const poolData = await poolResponse.json();
          const pool = poolData.data.find(p => p._id === position.pool._id);

          if (!pool) continue;

          // Calculate time elapsed
          const timeElapsedMs = Date.now() - position.startTime;
          const timeElapsedHours = timeElapsedMs / (1000 * 60 * 60);
          const timeElapsedDays = timeElapsedHours / 24;

          // Estimate current price from pool reserves
          const btcReserve = parseFloat(pool.token0Reserve || pool.tvl);
          const tokenReserve = parseFloat(pool.token1Reserve || 1);
          const currentPrice = btcReserve / tokenReserve;

          // Calculate pool share
          const poolShare = position.depositedBTC / (pool.tvl + position.depositedBTC);

          // Estimate daily volume (use recent volume if available, else historical average)
          let dailyVolume = pool.volume24h;
          if (dailyVolume === 0 && pool.volume7d > 0) {
            dailyVolume = pool.volume7d / 7;
          } else if (dailyVolume === 0 && pool.volumeAllTime > 0) {
            // Conservative estimate: use 10% of historical average
            dailyVolume = (pool.volumeAllTime / 133) * 0.1;
          }

          // Calculate fees earned
          const dailyFees = dailyVolume * (pool.fee / 1000000); // fee is in basis points
          const accumulatedFees = dailyFees * poolShare * timeElapsedDays;
          position.feesEarned = Math.max(0, accumulatedFees);

          // Calculate metrics using backend
          const calcResponse = await fetch('/api/market-maker/calculate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              depositedBTC: position.depositedBTC,
              feesEarned: position.feesEarned,
              entryPrice: position.entryPrice,
              currentPrice: currentPrice,
              timeElapsedHours: timeElapsedHours
            })
          });

          if (calcResponse.ok) {
            const calcData = await calcResponse.json();
            if (calcData.success) {
              position.ilLoss = calcData.data.ilPercent / 100; // Store as decimal
              position.apy = calcData.data.apy;
            }
          }

          // Update status
          if (position.status === 'pending-auth') {
            // Keep as pending until wallet connected
          } else {
            position.status = 'active';
          }

        } catch (error) {
          console.error('Failed to update position:', error);
        }
      }

      saveMMLoc();
      renderMMPositions();
    }

    // Update positions every 5 minutes
    setInterval(updateMMPositions, 5 * 60 * 1000);
    
    // Initial update after 10 seconds
    setTimeout(updateMMPositions, 10000);

    // ===== RADPAD FUNCTIONS =====
    
    function updateSliders() {
      const feeTier = document.getElementById('feeTier').value;
      const lpRate = document.getElementById('lpRate').value;
      const rewardRate = document.getElementById('rewardRate').value;
      
      document.getElementById('feeTierVal').textContent = (feeTier / 10000).toFixed(1) + '%';
      document.getElementById('lpRateVal').textContent = lpRate + '%';
      document.getElementById('rewardRateVal').textContent = rewardRate + '%';
    }
    
    function updatePreview() {
      const runeName = document.getElementById('runeName').value;
      const symbol = document.getElementById('symbol').value;
      const feeTier = document.getElementById('feeTier').value;
      const lpRate = document.getElementById('lpRate').value;
      const rewardRate = document.getElementById('rewardRate').value;
      const blockWithdrawals = document.getElementById('blockWithdrawals').checked;
      
      document.getElementById('prevName').textContent = runeName || '-';
      document.getElementById('prevSymbol').textContent = symbol || '-';
      document.getElementById('prevFee').textContent = (feeTier / 10000).toFixed(1) + '%';
      document.getElementById('prevLP').textContent = lpRate + '%';
      document.getElementById('prevCreator').textContent = (100 - lpRate) + '%';
      
      const actualReward = (rewardRate / 100) * 66.67;
      document.getElementById('prevReward').textContent = actualReward.toFixed(2) + '%';
      
      document.getElementById('prevWithdraw').textContent = blockWithdrawals ? 'Blocked' : 'Allowed';
    }
    
    async function launchRune() {
      if (!S.accessToken) {
        toast('Please connect your wallet first', 'error');
        return;
      }
      
      const runeName = document.getElementById('runeName').value.trim();
      const symbol = document.getElementById('symbol').value.trim();
      const description = document.getElementById('description').value.trim();
      const inscriptionContent = document.getElementById('inscriptionContent').value.trim();
      
      if (!runeName || !symbol || !description) {
        toast('Please fill in all required fields', 'error');
        return;
      }
      
      try {
        toast('Building commit transaction...', 'info');
        
        const etchParams = {
          runeName,
          inscriptionType: 'text/plain',
          inscriptionContent: inscriptionContent || 'Etched on RadFi',
          userAddress: S.tradingAddress || S.userAddress,
          feeTier: parseInt(document.getElementById('feeTier').value),
          diamondHandRewardRate: parseInt(document.getElementById('rewardRate').value) / 100,
          blockWithdrawals: document.getElementById('blockWithdrawals').checked,
          addLpSatsRate: parseInt(document.getElementById('lpRate').value) / 100
        };
        
        const commitResponse = await fetch('/api/etch/commit-tx', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${S.accessToken}`
          },
          body: JSON.stringify(etchParams)
        });
        
        const commitData = await commitResponse.json();
        
        if (!commitData.success) {
          throw new Error(commitData.error || 'Failed to build commit transaction');
        }
        
        toast('Please sign the transaction in your wallet', 'info');
        
        let signedPsbt;
        if (S.walletType === 'unisat') {
          signedPsbt = await window.unisat.signPsbt(commitData.psbt);
        } else if (S.walletType === 'xverse') {
          throw new Error('Xverse PSBT signing not implemented yet');
        } else if (S.walletType === 'okx') {
          signedPsbt = await window.okxwallet.bitcoin.signPsbt(commitData.psbt);
        }
        
        const submitResponse = await fetch('/api/etch/submit-etching', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${S.accessToken}`
          },
          body: JSON.stringify({
            signedBase64Psbt: signedPsbt,
            runeName,
            inscriptionType: 'text/plain',
            inscriptionContent: inscriptionContent || 'Etched on RadFi',
            symbol,
            creator: S.userAddress,
            description,
            displayTicker: document.getElementById('displayTicker').value || symbol,
            social: {
              x: document.getElementById('socialX').value || undefined,
              telegram: document.getElementById('socialTg').value || undefined
            }
          })
        });
        
        const submitData = await submitResponse.json();
        
        if (!submitData.success) {
          throw new Error(submitData.error || 'Failed to submit etching');
        }
        
        toast('Rune etching submitted successfully! ', 'success');
        setTimeout(() => loadEtchedRunes(), 2000);
        
      } catch (error) {
        console.error('Launch error:', error);
        toast('Failed to launch rune: ' + error.message, 'error');
      }
    }
    
    async function loadEtchedRunes() {
      try {
        const response = await fetch('/api/etch/runes?pageSize=20&sort=-createdAt');
        const data = await response.json();
        S.etchedRunes = data.data || [];
        renderEtchedRunes();
      } catch (error) {
        console.error('Failed to load etched runes:', error);
      }
    }
    
    function renderEtchedRunes() {
      const container = document.getElementById('etchedRunes');
      if (!container) return;
      
      if (S.etchedRunes.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 2rem; grid-column: 1/-1; color: var(--text-secondary);">No runes etched yet. Be the first!</div>';
        return;
      }
      
      container.innerHTML = S.etchedRunes.map(rune => `
        <div class="etch-item">
          <div class="etch-item-header">
            <div class="etch-item-name">${rune.runeName}</div>
            <div class="etch-item-symbol">${rune.symbol}</div>
          </div>
          <div class="etch-item-description">
            ${rune.description || 'No description provided'}
          </div>
          <div class="etch-item-stats">
            <div class="etch-item-stat">
              <span class="label">Market Cap</span>
              <span class="value">${fmtCompact(rune.marketCap || 0)}</span>
            </div>
            <div class="etch-item-stat">
              <span class="label">Holders</span>
              <span class="value">${rune.holders || 0}</span>
            </div>
            <div class="etch-item-stat">
              <span class="label">Fee Tier</span>
              <span class="value">${((rune.feeTier || 10000) / 10000).toFixed(1)}%</span>
            </div>
            <div class="etch-item-stat">
              <span class="label">LP Allocation</span>
              <span class="value">${((rune.addLpSatsRate || 0) * 100).toFixed(0)}%</span>
            </div>
          </div>
          ${rune.social && (rune.social.x || rune.social.telegram) ? `
            <div class="etch-item-socials">
              ${rune.social.x ? `<a href="${rune.social.x}" class="social-link" target="_blank"></a>` : ''}
              ${rune.social.telegram ? `<a href="${rune.social.telegram}" class="social-link" target="_blank"></a>` : ''}
            </div>
          ` : ''}
        </div>
      `).join('');
    }

    // INIT - Enhanced with proper DOM ready check
    function initializeApp() {
      console.log('[RadLabs] Initializing...');
      
      try {
        // 1. Fetch BTC price
        fetchBTCPrice();
        setInterval(fetchBTCPrice, 60000); // Update every minute
        
        // 2. Restore session first
        restoreSession();
        
        // 3. Set up lottery timer
        updateLotteryTimer();
        setInterval(updateLotteryTimer, 1000);
        
        // 4. Initialize chart
        if (document.getElementById('tvChart')) {
          initChart();
          console.log('[RadLabs] Chart initialized');
        }
        
        // 5. Load tokens (async)
        loadTokens();
        
        // 6. Load MM positions
        loadMMLoc();
        
        // 7. Initialize RadPad if elements exist
        if (document.getElementById('feeTier')) {
          updateSliders();
          updatePreview();
        }
        
        // 8. Populate MM tokens after brief delay
        setTimeout(() => {
          if (S.tokens.length > 0) {
            populateMMTokens();
            console.log('[RadLabs] MM tokens populated');
          } else {
            // Retry if tokens not loaded yet
            setTimeout(() => {
              if (S.tokens.length > 0) populateMMTokens();
            }, 2000);
          }
        }, 1000);
        
        // 9. Load etched runes if on RadPad page
        if (document.getElementById('etchedRunes')) {
          loadEtchedRunes();
        }
        
        // 10. Update MM positions periodically
        setInterval(updateMMPositions, 5 * 60 * 1000);
        setTimeout(updateMMPositions, 10000);
        
        console.log('[RadLabs] Initialization complete');
      } catch (error) {
        console.error('[RadLabs] Initialization error:', error);
      }
    }
    
    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      initializeApp();
    }
  </script>
</body>
</html>
